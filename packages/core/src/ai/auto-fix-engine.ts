/**
 * @fileoverview Auto-fix Engine - Automated code repair execution
 * 
 * **Week 33: Auto-fixing (File 1/3)**
 * 
 * **Purpose**: Automated code repair with AST transformations, rollback capability,
 * and safe batch fixing. Executes fixes generated by Intelligent Fix Suggester
 * with comprehensive validation and conflict resolution.
 * 
 * **Features**:
 * - AST-based transformations (safe modifications)
 * - Multi-fix orchestration (apply multiple fixes)
 * - Rollback capability (undo if fails)
 * - Dry-run mode (preview without applying)
 * - Batch fixing (multiple files)
 * - Fix conflict resolution
 * - Progress tracking and reporting
 * 
 * **Integration**:
 * - Uses Intelligent Fix Suggester for fix generation (Week 31)
 * - Validated by Fix Validator (Week 33, File 2)
 * - Strategy selection via Fix Strategy Selector (Week 33, File 3)
 * - AST manipulation via TypeScript Compiler API
 * 
 * **Enterprise Features**:
 * - Git integration for rollback
 * - Atomic transactions (all-or-nothing)
 * - Conflict detection and resolution
 * - Audit trail for all changes
 * 
 * @module @odavl-studio/insight-core/ai
 * @category AI & Intelligence
 * @phase Phase 4 - Week 33
 * @since 1.33.0
 */

import * as ts from 'typescript';
import { promises as fs } from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

// ============================================================================
// ENUMS
// ============================================================================

/**
 * Fix execution mode
 */
export enum FixMode {
  /** Preview changes without applying */
  DRY_RUN = 'DRY_RUN',
  
  /** Apply changes to files */
  APPLY = 'APPLY',
  
  /** Apply and create git commit */
  APPLY_AND_COMMIT = 'APPLY_AND_COMMIT',
}

/**
 * Fix application status
 */
export enum FixStatus {
  /** Fix not yet attempted */
  PENDING = 'PENDING',
  
  /** Fix currently being applied */
  IN_PROGRESS = 'IN_PROGRESS',
  
  /** Fix applied successfully */
  SUCCESS = 'SUCCESS',
  
  /** Fix failed to apply */
  FAILED = 'FAILED',
  
  /** Fix skipped (conflict or invalid) */
  SKIPPED = 'SKIPPED',
  
  /** Fix rolled back */
  ROLLED_BACK = 'ROLLED_BACK',
}

/**
 * Conflict resolution strategy
 */
export enum ConflictResolution {
  /** Skip conflicting fixes */
  SKIP = 'SKIP',
  
  /** Apply first fix only */
  FIRST_WINS = 'FIRST_WINS',
  
  /** Apply last fix only */
  LAST_WINS = 'LAST_WINS',
  
  /** Attempt to merge fixes */
  MERGE = 'MERGE',
  
  /** Prompt user for resolution */
  MANUAL = 'MANUAL',
}

/**
 * Transformation type for AST modifications
 */
export enum TransformationType {
  /** Add new node */
  ADD = 'ADD',
  
  /** Remove existing node */
  REMOVE = 'REMOVE',
  
  /** Replace node with new node */
  REPLACE = 'REPLACE',
  
  /** Modify node properties */
  MODIFY = 'MODIFY',
  
  /** Reorder nodes */
  REORDER = 'REORDER',
}

// ============================================================================
// INTERFACES
// ============================================================================

/**
 * Fix to be applied to code
 */
export interface CodeFix {
  /** Unique fix identifier */
  id: string;
  
  /** File to modify */
  filePath: string;
  
  /** Issue being fixed */
  issueId: string;
  
  /** Fix description */
  description: string;
  
  /** Fix category */
  category: 'syntax' | 'import' | 'type' | 'security' | 'performance' | 'style' | 'complexity';
  
  /** Fix transformations */
  transformations: ASTTransformation[];
  
  /** Expected diff */
  diff?: string;
  
  /** Confidence score (0-1) */
  confidence: number;
  
  /** Estimated risk (0-1) */
  risk: number;
  
  /** Dependencies (other fixes that must be applied first) */
  dependencies?: string[];
}

/**
 * AST transformation to apply
 */
export interface ASTTransformation {
  /** Transformation type */
  type: TransformationType;
  
  /** Target node location */
  target: NodeLocation;
  
  /** New code (for ADD, REPLACE, MODIFY) */
  newCode?: string;
  
  /** New node position (for ADD, REORDER) */
  position?: 'before' | 'after' | 'first-child' | 'last-child';
  
  /** Properties to modify (for MODIFY) */
  properties?: Record<string, unknown>;
}

/**
 * Node location in source file
 */
export interface NodeLocation {
  /** Start line (1-based) */
  startLine: number;
  
  /** Start column (0-based) */
  startColumn: number;
  
  /** End line (1-based) */
  endLine: number;
  
  /** End column (0-based) */
  endColumn: number;
  
  /** Node kind (TypeScript syntax kind) */
  kind?: ts.SyntaxKind;
  
  /** Node text (for verification) */
  text?: string;
}

/**
 * Fix application result
 */
export interface FixResult {
  /** Fix that was attempted */
  fix: CodeFix;
  
  /** Application status */
  status: FixStatus;
  
  /** Applied transformations */
  transformationsApplied: number;
  
  /** Actual diff */
  diff?: string;
  
  /** Error message (if failed) */
  error?: string;
  
  /** Rollback info (if rolled back) */
  rollback?: RollbackInfo;
  
  /** Execution time (ms) */
  executionTime: number;
}

/**
 * Rollback information
 */
export interface RollbackInfo {
  /** Original file content */
  originalContent: string;
  
  /** Backup file path */
  backupPath?: string;
  
  /** Git commit hash (if committed) */
  gitCommit?: string;
  
  /** Rollback timestamp */
  rolledBackAt: Date;
  
  /** Rollback reason */
  reason: string;
}

/**
 * Batch fix execution options
 */
export interface BatchFixOptions {
  /** Execution mode */
  mode: FixMode;
  
  /** Conflict resolution strategy */
  conflictResolution: ConflictResolution;
  
  /** Stop on first failure */
  stopOnFailure: boolean;
  
  /** Create backups before applying */
  createBackups: boolean;
  
  /** Git branch for fixes */
  gitBranch?: string;
  
  /** Maximum fixes to apply */
  maxFixes?: number;
  
  /** Timeout per fix (ms) */
  timeoutPerFix?: number;
  
  /** Progress callback */
  onProgress?: (result: FixResult) => void;
}

/**
 * Batch fix execution result
 */
export interface BatchFixResult {
  /** Total fixes attempted */
  total: number;
  
  /** Successful fixes */
  successful: number;
  
  /** Failed fixes */
  failed: number;
  
  /** Skipped fixes */
  skipped: number;
  
  /** Individual results */
  results: FixResult[];
  
  /** Conflicts detected */
  conflicts: FixConflict[];
  
  /** Total execution time (ms) */
  totalTime: number;
  
  /** Files modified */
  filesModified: string[];
  
  /** Git commit hash (if committed) */
  gitCommit?: string;
}

/**
 * Detected fix conflict
 */
export interface FixConflict {
  /** First fix */
  fix1: CodeFix;
  
  /** Second fix */
  fix2: CodeFix;
  
  /** Conflict type */
  type: 'overlapping' | 'dependency' | 'semantic';
  
  /** Conflict description */
  description: string;
  
  /** Resolution applied */
  resolution?: ConflictResolution;
  
  /** Resolution result */
  resolutionResult?: 'fix1-applied' | 'fix2-applied' | 'both-applied' | 'none-applied';
}

/**
 * File state snapshot
 */
interface FileSnapshot {
  /** File path */
  filePath: string;
  
  /** Original content */
  content: string;
  
  /** Original AST */
  ast: ts.SourceFile;
  
  /** Backup path */
  backupPath?: string;
  
  /** Git hash before changes */
  gitHash?: string;
}

// ============================================================================
// AUTO-FIX ENGINE
// ============================================================================

/**
 * Auto-fix Engine
 * 
 * Automated code repair with AST transformations and rollback capability.
 * 
 * **Usage**:
 * ```typescript
 * const engine = new AutoFixEngine('/path/to/project');
 * 
 * // Dry-run mode (preview)
 * const preview = await engine.applyFix(fix, { mode: FixMode.DRY_RUN });
 * console.log('Diff:', preview.diff);
 * 
 * // Apply single fix
 * const result = await engine.applyFix(fix, { mode: FixMode.APPLY });
 * if (result.status !== FixStatus.SUCCESS) {
 *   console.error('Fix failed:', result.error);
 * }
 * 
 * // Apply multiple fixes
 * const batchResult = await engine.applyBatch(fixes, {
 *   mode: FixMode.APPLY_AND_COMMIT,
 *   conflictResolution: ConflictResolution.MERGE,
 *   stopOnFailure: false,
 *   createBackups: true,
 *   gitBranch: 'auto-fix/batch-123',
 *   onProgress: (result) => console.log(`Fixed ${result.fix.id}`)
 * });
 * 
 * // Rollback if needed
 * if (batchResult.failed > 0) {
 *   await engine.rollback(batchResult);
 * }
 * ```
 */
export class AutoFixEngine {
  private projectRoot: string;
  private fileSnapshots: Map<string, FileSnapshot> = new Map();
  
  constructor(projectRoot: string) {
    this.projectRoot = projectRoot;
  }
  
  // ==========================================================================
  // PUBLIC API
  // ==========================================================================
  
  /**
   * Apply single fix to code
   * 
   * @param fix - Fix to apply
   * @param options - Execution options
   * @returns Fix result
   * 
   * @example
   * ```typescript
   * const result = await engine.applyFix(fix, { 
   *   mode: FixMode.APPLY,
   *   createBackup: true 
   * });
   * ```
   */
  async applyFix(
    fix: CodeFix,
    options: { mode: FixMode; createBackup?: boolean } = { mode: FixMode.APPLY }
  ): Promise<FixResult> {
    const startTime = Date.now();
    
    try {
      // Validate fix
      this.validateFix(fix);
      
      // Read file
      const filePath = path.resolve(this.projectRoot, fix.filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      
      // Parse AST
      const ast = ts.createSourceFile(
        filePath,
        content,
        ts.ScriptTarget.Latest,
        true,
        ts.ScriptKind.TS
      );
      
      // Create snapshot
      if (options.createBackup) {
        await this.createSnapshot(filePath, content, ast);
      }
      
      // Apply transformations
      let transformedAst = ast;
      let transformationsApplied = 0;
      
      for (const transformation of fix.transformations) {
        transformedAst = this.applyTransformation(transformedAst, transformation);
        transformationsApplied++;
      }
      
      // Generate new content
      const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
      const newContent = printer.printFile(transformedAst);
      
      // Calculate diff
      const diff = this.calculateDiff(content, newContent);
      
      // Apply changes (if not dry-run)
      if (options.mode !== FixMode.DRY_RUN) {
        await fs.writeFile(filePath, newContent, 'utf-8');
      }
      
      return {
        fix,
        status: FixStatus.SUCCESS,
        transformationsApplied,
        diff,
        executionTime: Date.now() - startTime,
      };
      
    } catch (error) {
      return {
        fix,
        status: FixStatus.FAILED,
        transformationsApplied: 0,
        error: error instanceof Error ? error.message : String(error),
        executionTime: Date.now() - startTime,
      };
    }
  }
  
  /**
   * Apply multiple fixes (batch operation)
   * 
   * @param fixes - Fixes to apply
   * @param options - Batch execution options
   * @returns Batch result
   * 
   * @example
   * ```typescript
   * const result = await engine.applyBatch(fixes, {
   *   mode: FixMode.APPLY,
   *   conflictResolution: ConflictResolution.MERGE,
   *   stopOnFailure: false,
   *   onProgress: (r) => console.log(r.fix.id)
   * });
   * ```
   */
  async applyBatch(
    fixes: CodeFix[],
    options: BatchFixOptions
  ): Promise<BatchFixResult> {
    const startTime = Date.now();
    
    // Create git branch (if requested)
    if (options.gitBranch && options.mode === FixMode.APPLY_AND_COMMIT) {
      this.createGitBranch(options.gitBranch);
    }
    
    // Detect conflicts
    const conflicts = this.detectConflicts(fixes);
    
    // Resolve conflicts
    const resolvedFixes = this.resolveConflicts(fixes, conflicts, options.conflictResolution);
    
    // Apply fixes
    const results: FixResult[] = [];
    const filesModified = new Set<string>();
    
    for (const fix of resolvedFixes) {
      // Check max fixes limit
      if (options.maxFixes && results.length >= options.maxFixes) {
        break;
      }
      
      // Apply fix
      const result = await this.applyFix(fix, {
        mode: options.mode,
        createBackup: options.createBackups,
      });
      
      results.push(result);
      
      if (result.status === FixStatus.SUCCESS) {
        filesModified.add(fix.filePath);
      }
      
      // Progress callback
      if (options.onProgress) {
        options.onProgress(result);
      }
      
      // Stop on failure (if configured)
      if (options.stopOnFailure && result.status === FixStatus.FAILED) {
        break;
      }
    }
    
    // Count results
    const successful = results.filter((r) => r.status === FixStatus.SUCCESS).length;
    const failed = results.filter((r) => r.status === FixStatus.FAILED).length;
    const skipped = fixes.length - resolvedFixes.length;
    
    // Create git commit (if requested)
    let gitCommit: string | undefined;
    if (options.mode === FixMode.APPLY_AND_COMMIT && successful > 0) {
      gitCommit = this.createGitCommit(
        `Auto-fix: Applied ${successful} fixes`,
        Array.from(filesModified)
      );
    }
    
    return {
      total: fixes.length,
      successful,
      failed,
      skipped,
      results,
      conflicts,
      totalTime: Date.now() - startTime,
      filesModified: Array.from(filesModified),
      gitCommit,
    };
  }
  
  /**
   * Rollback applied fixes
   * 
   * @param batchResult - Batch result to rollback
   * 
   * @example
   * ```typescript
   * await engine.rollback(batchResult);
   * ```
   */
  async rollback(batchResult: BatchFixResult): Promise<void> {
    // Rollback git commit (if exists)
    if (batchResult.gitCommit) {
      this.rollbackGitCommit(batchResult.gitCommit);
    }
    
    // Restore files from snapshots
    for (const filePath of batchResult.filesModified) {
      const snapshot = this.fileSnapshots.get(filePath);
      if (snapshot) {
        await fs.writeFile(snapshot.filePath, snapshot.content, 'utf-8');
      }
    }
    
    // Clear snapshots
    this.fileSnapshots.clear();
  }
  
  // ==========================================================================
  // PRIVATE METHODS - TRANSFORMATIONS
  // ==========================================================================
  
  /**
   * Apply single AST transformation
   */
  private applyTransformation(
    ast: ts.SourceFile,
    transformation: ASTTransformation
  ): ts.SourceFile {
    const transformer = <T extends ts.Node>(context: ts.TransformationContext) => {
      return (rootNode: T): T => {
        const visit = (node: ts.Node): ts.Node => {
          // Find target node
          if (this.isTargetNode(node, transformation.target)) {
            // Apply transformation
            switch (transformation.type) {
              case TransformationType.ADD:
                return this.addNode(node, transformation);
              case TransformationType.REMOVE:
                return this.removeNode();
              case TransformationType.REPLACE:
                return this.replaceNode(node, transformation);
              case TransformationType.MODIFY:
                return this.modifyNode(node, transformation);
              case TransformationType.REORDER:
                return this.reorderNode(node, transformation);
              default:
                return node;
            }
          }
          
          return ts.visitEachChild(node, visit, context);
        };
        
        return ts.visitNode(rootNode, visit) as T;
      };
    };
    
    const result = ts.transform(ast, [transformer]);
    return result.transformed[0] as ts.SourceFile;
  }
  
  /**
   * Check if node matches target location
   */
  private isTargetNode(node: ts.Node, target: NodeLocation): boolean {
    const sourceFile = node.getSourceFile();
    const start = sourceFile.getLineAndCharacterOfPosition(node.getStart());
    const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());
    
    return (
      start.line + 1 === target.startLine &&
      start.character === target.startColumn &&
      end.line + 1 === target.endLine &&
      end.character === target.endColumn
    );
  }
  
  /**
   * Add new node
   */
  private addNode(node: ts.Node, transformation: ASTTransformation): ts.Node {
    if (!transformation.newCode) return node;
    
    // Parse new code
    const newNode = this.parseCode(transformation.newCode);
    
    // Add based on position
    switch (transformation.position) {
      case 'before':
        // Return array with new node before existing
        return ts.factory.createNodeArray([newNode, node]) as unknown as ts.Node;
      case 'after':
        // Return array with new node after existing
        return ts.factory.createNodeArray([node, newNode]) as unknown as ts.Node;
      case 'first-child':
        // Add as first child
        if (ts.isBlock(node) || ts.isSourceFile(node)) {
          return ts.factory.updateBlock(node as ts.Block, [
            newNode as ts.Statement,
            ...(node as ts.Block).statements,
          ]) as unknown as ts.Node;
        }
        return node;
      case 'last-child':
        // Add as last child
        if (ts.isBlock(node) || ts.isSourceFile(node)) {
          return ts.factory.updateBlock(node as ts.Block, [
            ...(node as ts.Block).statements,
            newNode as ts.Statement,
          ]) as unknown as ts.Node;
        }
        return node;
      default:
        return node;
    }
  }
  
  /**
   * Remove node
   */
  private removeNode(): ts.Node {
    // Return undefined to remove (will be filtered out by visitor)
    return undefined as unknown as ts.Node;
  }
  
  /**
   * Replace node with new code
   */
  private replaceNode(node: ts.Node, transformation: ASTTransformation): ts.Node {
    if (!transformation.newCode) return node;
    
    // Parse new code
    return this.parseCode(transformation.newCode);
  }
  
  /**
   * Modify node properties
   */
  private modifyNode(node: ts.Node, transformation: ASTTransformation): ts.Node {
    if (!transformation.properties) return node;
    
    // Clone node with modified properties
    const modified = { ...node, ...transformation.properties };
    return modified as ts.Node;
  }
  
  /**
   * Reorder node
   */
  private reorderNode(node: ts.Node, transformation: ASTTransformation): ts.Node {
    // Reordering handled at parent level
    return node;
  }
  
  /**
   * Parse code string into AST node
   */
  private parseCode(code: string): ts.Node {
    const sourceFile = ts.createSourceFile(
      'temp.ts',
      code,
      ts.ScriptTarget.Latest,
      true,
      ts.ScriptKind.TS
    );
    
    // Return first statement
    return sourceFile.statements[0];
  }
  
  // ==========================================================================
  // PRIVATE METHODS - CONFLICT DETECTION
  // ==========================================================================
  
  /**
   * Detect conflicts between fixes
   */
  private detectConflicts(fixes: CodeFix[]): FixConflict[] {
    const conflicts: FixConflict[] = [];
    
    for (let i = 0; i < fixes.length; i++) {
      for (let j = i + 1; j < fixes.length; j++) {
        const fix1 = fixes[i];
        const fix2 = fixes[j];
        
        // Check if same file
        if (fix1.filePath !== fix2.filePath) continue;
        
        // Check for overlapping transformations
        if (this.hasOverlappingTransformations(fix1, fix2)) {
          conflicts.push({
            fix1,
            fix2,
            type: 'overlapping',
            description: `Fixes ${fix1.id} and ${fix2.id} modify overlapping code regions`,
          });
        }
        
        // Check for dependency conflicts
        if (fix1.dependencies?.includes(fix2.id) && fix2.dependencies?.includes(fix1.id)) {
          conflicts.push({
            fix1,
            fix2,
            type: 'dependency',
            description: `Circular dependency between ${fix1.id} and ${fix2.id}`,
          });
        }
      }
    }
    
    return conflicts;
  }
  
  /**
   * Check if fixes have overlapping transformations
   */
  private hasOverlappingTransformations(fix1: CodeFix, fix2: CodeFix): boolean {
    for (const t1 of fix1.transformations) {
      for (const t2 of fix2.transformations) {
        if (this.locationsOverlap(t1.target, t2.target)) {
          return true;
        }
      }
    }
    return false;
  }
  
  /**
   * Check if two locations overlap
   */
  private locationsOverlap(loc1: NodeLocation, loc2: NodeLocation): boolean {
    // Check if ranges overlap
    return !(
      loc1.endLine < loc2.startLine ||
      loc2.endLine < loc1.startLine ||
      (loc1.endLine === loc2.startLine && loc1.endColumn <= loc2.startColumn) ||
      (loc2.endLine === loc1.startLine && loc2.endColumn <= loc1.startColumn)
    );
  }
  
  /**
   * Resolve conflicts based on strategy
   */
  private resolveConflicts(
    fixes: CodeFix[],
    conflicts: FixConflict[],
    strategy: ConflictResolution
  ): CodeFix[] {
    if (conflicts.length === 0) return fixes;
    
    const resolved: CodeFix[] = [];
    const skipped = new Set<string>();
    
    // Mark conflicts for resolution
    for (const conflict of conflicts) {
      switch (strategy) {
        case ConflictResolution.SKIP:
          // Skip both fixes
          skipped.add(conflict.fix1.id);
          skipped.add(conflict.fix2.id);
          conflict.resolution = strategy;
          conflict.resolutionResult = 'none-applied';
          break;
          
        case ConflictResolution.FIRST_WINS:
          // Skip second fix
          skipped.add(conflict.fix2.id);
          conflict.resolution = strategy;
          conflict.resolutionResult = 'fix1-applied';
          break;
          
        case ConflictResolution.LAST_WINS:
          // Skip first fix
          skipped.add(conflict.fix1.id);
          conflict.resolution = strategy;
          conflict.resolutionResult = 'fix2-applied';
          break;
          
        case ConflictResolution.MERGE:
          // Try to merge (complex, may fail)
          // For now, apply both and let validation catch issues
          conflict.resolution = strategy;
          conflict.resolutionResult = 'both-applied';
          break;
          
        case ConflictResolution.MANUAL:
          // Skip both, require manual intervention
          skipped.add(conflict.fix1.id);
          skipped.add(conflict.fix2.id);
          conflict.resolution = strategy;
          conflict.resolutionResult = 'none-applied';
          break;
      }
    }
    
    // Return non-skipped fixes
    return fixes.filter((fix) => !skipped.has(fix.id));
  }
  
  // ==========================================================================
  // PRIVATE METHODS - UTILITIES
  // ==========================================================================
  
  /**
   * Validate fix before applying
   */
  private validateFix(fix: CodeFix): void {
    if (!fix.id) throw new Error('Fix must have an ID');
    if (!fix.filePath) throw new Error('Fix must have a file path');
    if (!fix.transformations || fix.transformations.length === 0) {
      throw new Error('Fix must have at least one transformation');
    }
  }
  
  /**
   * Create file snapshot for rollback
   */
  private async createSnapshot(
    filePath: string,
    content: string,
    ast: ts.SourceFile
  ): Promise<void> {
    const backupPath = `${filePath}.backup-${Date.now()}`;
    await fs.writeFile(backupPath, content, 'utf-8');
    
    this.fileSnapshots.set(filePath, {
      filePath,
      content,
      ast,
      backupPath,
    });
  }
  
  /**
   * Calculate diff between old and new content
   */
  private calculateDiff(oldContent: string, newContent: string): string {
    // Simple line-based diff
    const oldLines = oldContent.split('\n');
    const newLines = newContent.split('\n');
    
    const diff: string[] = [];
    const maxLen = Math.max(oldLines.length, newLines.length);
    
    for (let i = 0; i < maxLen; i++) {
      const oldLine = oldLines[i] || '';
      const newLine = newLines[i] || '';
      
      if (oldLine !== newLine) {
        if (oldLine) diff.push(`- ${oldLine}`);
        if (newLine) diff.push(`+ ${newLine}`);
      }
    }
    
    return diff.join('\n');
  }
  
  /**
   * Create git branch
   */
  private createGitBranch(branchName: string): void {
    try {
      execSync(`git checkout -b ${branchName}`, {
        cwd: this.projectRoot,
        stdio: 'ignore',
      });
    } catch {
      // Branch may already exist, ignore error
    }
  }
  
  /**
   * Create git commit
   */
  private createGitCommit(message: string, files: string[]): string {
    // Stage files
    for (const file of files) {
      execSync(`git add ${file}`, {
        cwd: this.projectRoot,
        stdio: 'ignore',
      });
    }
    
    // Commit
    execSync(`git commit -m "${message}"`, {
      cwd: this.projectRoot,
      stdio: 'ignore',
    });
    
    // Get commit hash
    const hash = execSync('git rev-parse HEAD', {
      cwd: this.projectRoot,
      encoding: 'utf-8',
    }).trim();
    
    return hash;
  }
  
  /**
   * Rollback git commit
   */
  private rollbackGitCommit(commitHash: string): void {
    execSync(`git reset --hard ${commitHash}^`, {
      cwd: this.projectRoot,
      stdio: 'ignore',
    });
  }
}
