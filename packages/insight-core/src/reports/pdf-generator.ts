/**
 * PDF Report Generator for ODAVL Insight
 * 
 * Generates executive PDF reports with:
 * - Professional multi-page layout
 * - Summary statistics with visual indicators
 * - Detailed issue tables with pagination
 * - File-by-file breakdown
 * - Header/footer with branding
 * 
 * Usage:
 *   const generator = new PDFReportGenerator();
 *   const pdfBuffer = await generator.generate(diagnostics, options);
 *   fs.writeFileSync('report.pdf', pdfBuffer);
 */

import { jsPDF } from 'jspdf';
import 'jspdf-autotable';

export interface PDFReportDiagnostic {
    file: string;
    line: number;
    message: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
    source: string;
    code?: string;
}

export interface PDFReportOptions {
    title?: string;
    workspaceRoot?: string;
    timestamp?: string;
    includeFileBreakdown?: boolean;
    companyName?: string;
    companyLogo?: string; // Base64 encoded image or URL
}

export class PDFReportGenerator {
    private readonly pageWidth = 210; // A4 width in mm
    private readonly pageHeight = 297; // A4 height in mm
    private readonly margin = 20;

    /**
     * Generate complete PDF report from diagnostics data
     */
    async generate(diagnostics: Record<string, PDFReportDiagnostic[]>, options: PDFReportOptions = {}): Promise<Buffer> {
        const {
            title = 'ODAVL Insight Report',
            workspaceRoot = 'Workspace',
            timestamp = new Date().toISOString(),
            includeFileBreakdown = true,
            companyName = 'ODAVL',
            companyLogo
        } = options;

        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        const stats = this.calculateStats(diagnostics);
        let currentPage = 1;

        // Page 1: Cover + Executive Summary
        this.addCoverPage(doc, title, workspaceRoot, timestamp, companyName, companyLogo);

        doc.addPage();
        currentPage++;
        this.addHeader(doc, title, currentPage);
        this.addExecutiveSummary(doc, stats);
        this.addFooter(doc, currentPage);

        // Page 2+: Issue Details
        doc.addPage();
        currentPage++;
        this.addHeader(doc, title, currentPage);
        const issuesStartY = this.addIssuesTable(doc, diagnostics, this.margin + 15);
        this.addFooter(doc, currentPage);

        // Additional pages if table spans multiple pages
        if (issuesStartY > this.pageHeight - this.margin - 15) {
            // jspdf-autotable handles pagination automatically
            currentPage = (doc as any).internal.getNumberOfPages();
        }

        // File Breakdown (optional)
        if (includeFileBreakdown && Object.keys(diagnostics).length > 0) {
            doc.addPage();
            currentPage++;
            this.addHeader(doc, title, currentPage);
            this.addFileBreakdown(doc, diagnostics);
            this.addFooter(doc, currentPage);
        }

        // Generate buffer
        const pdfBuffer = Buffer.from(doc.output('arraybuffer'));
        return pdfBuffer;
    }

    /**
     * Add cover page with branding
     */
    private addCoverPage(
        doc: jsPDF,
        title: string,
        workspaceRoot: string,
        timestamp: string,
        companyName: string,
        companyLogo?: string
    ): void {
        // Background gradient effect (simulated with rectangles)
        doc.setFillColor(102, 126, 234);
        doc.rect(0, 0, this.pageWidth, 80, 'F');

        doc.setFillColor(118, 75, 162);
        doc.rect(0, 80, this.pageWidth, 40, 'F');

        // Logo (if provided)
        if (companyLogo) {
            try {
                doc.addImage(companyLogo, 'PNG', this.margin, this.margin, 40, 40);
            } catch {
                // Ignore if logo fails to load
            }
        }

        // Title
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(32);
        doc.setFont('helvetica', 'bold');
        doc.text(title, this.pageWidth / 2, 60, { align: 'center' });

        // Subtitle
        doc.setFontSize(14);
        doc.setFont('helvetica', 'normal');
        doc.text(`Code Quality & Security Analysis`, this.pageWidth / 2, 75, { align: 'center' });

        // Metadata box
        doc.setFillColor(255, 255, 255);
        doc.roundedRect(this.margin, 140, this.pageWidth - 2 * this.margin, 60, 3, 3, 'F');

        doc.setTextColor(31, 41, 55);
        doc.setFontSize(11);
        doc.setFont('helvetica', 'bold');
        doc.text('Workspace:', this.margin + 10, 155);
        doc.setFont('helvetica', 'normal');
        doc.text(this.truncateText(workspaceRoot, 50), this.margin + 10, 163);

        doc.setFont('helvetica', 'bold');
        doc.text('Generated:', this.margin + 10, 175);
        doc.setFont('helvetica', 'normal');
        doc.text(this.formatTimestamp(timestamp), this.margin + 10, 183);

        doc.setFont('helvetica', 'bold');
        doc.text('Generated By:', this.margin + 10, 195);
        doc.setFont('helvetica', 'normal');
        doc.text(companyName, this.margin + 10, 203);

        // Footer
        doc.setFontSize(9);
        doc.setTextColor(107, 114, 128);
        doc.text('Confidential - For Internal Use Only', this.pageWidth / 2, this.pageHeight - 15, { align: 'center' });
    }

    /**
     * Add header to page
     */
    private addHeader(doc: jsPDF, title: string, pageNumber: number): void {
        doc.setFillColor(243, 244, 246);
        doc.rect(0, 0, this.pageWidth, 15, 'F');

        doc.setTextColor(75, 85, 99);
        doc.setFontSize(9);
        doc.setFont('helvetica', 'normal');
        doc.text(title, this.margin, 10);

        doc.text(`Page ${pageNumber}`, this.pageWidth - this.margin, 10, { align: 'right' });
    }

    /**
     * Add footer to page
     */
    private addFooter(doc: jsPDF, _pageNumber: number): void {
        doc.setFontSize(8);
        doc.setTextColor(107, 114, 128);
        doc.text(
            `ODAVL Insight â€¢ odavl.dev`,
            this.pageWidth / 2,
            this.pageHeight - 10,
            { align: 'center' }
        );
    }

    /**
     * Add executive summary section
     */
    private addExecutiveSummary(doc: jsPDF, stats: ReturnType<typeof this.calculateStats>): void {
        let yPos = this.margin + 15;

        // Title
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(17, 24, 39);
        doc.text('Executive Summary', this.margin, yPos);
        yPos += 12;

        // Health Score
        const healthScore = this.calculateHealthScore(stats);
        const healthColor = this.getHealthColor(healthScore);

        doc.setFillColor(...healthColor);
        doc.roundedRect(this.margin, yPos, 60, 20, 2, 2, 'F');

        doc.setTextColor(255, 255, 255);
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text('Health Score', this.margin + 30, yPos + 8, { align: 'center' });
        doc.setFontSize(18);
        doc.text(`${healthScore}/100`, this.margin + 30, yPos + 16, { align: 'center' });
        yPos += 28;

        // Statistics Grid
        const gridStartY = yPos;
        const colWidth = (this.pageWidth - 2 * this.margin) / 3;

        const statBoxes = [
            { label: 'Total Issues', value: stats.totalIssues.toString(), color: [107, 114, 128] as [number, number, number] },
            { label: 'Files Affected', value: stats.filesAffected.toString(), color: [99, 102, 241] as [number, number, number] },
            { label: 'Critical', value: stats.criticalCount.toString(), color: [220, 38, 38] as [number, number, number] },
            { label: 'High', value: stats.highCount.toString(), color: [245, 158, 11] as [number, number, number] },
            { label: 'Medium', value: stats.mediumCount.toString(), color: [59, 130, 246] as [number, number, number] },
            { label: 'Low', value: stats.lowCount.toString(), color: [16, 185, 129] as [number, number, number] }
        ];

        for (const [index, box] of statBoxes.entries()) {
            const row = Math.floor(index / 3);
            const col = index % 3;
            const x = this.margin + col * colWidth + 2;
            const y = gridStartY + row * 25;

            doc.setFillColor(249, 250, 251);
            doc.roundedRect(x, y, colWidth - 4, 20, 2, 2, 'F');

            doc.setTextColor(...box.color);
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.text(box.label, x + (colWidth - 4) / 2, y + 7, { align: 'center' });

            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text(box.value, x + (colWidth - 4) / 2, y + 16, { align: 'center' });
        }
        yPos = gridStartY + 55;

        // Top Issue Types
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(17, 24, 39);
        doc.text('Top Issue Types', this.margin, yPos);
        yPos += 8;

        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        for (const { source, count } of stats.topIssueTypes.slice(0, 5)) {
            doc.text(`â€¢ ${source}: ${count} issue${count === 1 ? '' : 's'}`, this.margin + 5, yPos);
            yPos += 6;
        }
        yPos += 5;

        // Most Affected Files
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text('Most Affected Files', this.margin, yPos);
        yPos += 8;

        doc.setFontSize(9);
        doc.setFont('courier', 'normal');
        for (const { file, count } of stats.mostAffectedFiles.slice(0, 5)) {
            const shortPath = this.shortenPath(file);
            doc.text(`${this.truncateText(shortPath, 60)} (${count})`, this.margin + 5, yPos);
            yPos += 6;
        }
    }

    /**
     * Add issues table with pagination
     */
    private addIssuesTable(doc: jsPDF, diagnostics: Record<string, PDFReportDiagnostic[]>, startY: number): number {
        const allIssues = Object.values(diagnostics).flat(1)
            .sort((a, b) => {
                const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
                return severityOrder[a.severity] - severityOrder[b.severity];
            });

        // Title
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(17, 24, 39);
        doc.text('Detailed Issues', this.margin, startY);

        // Prepare table data
        const tableData = allIssues.map(issue => [
            this.getSeveritySymbol(issue.severity),
            this.shortenPath(issue.file),
            issue.line.toString(),
            issue.source,
            this.truncateText(issue.message, 40),
            issue.code || '-'
        ]);

        // Generate table using autoTable
        (doc as any).autoTable({
            startY: startY + 5,
            head: [['Severity', 'File', 'Line', 'Source', 'Message', 'Code']],
            body: tableData,
            theme: 'grid',
            styles: {
                fontSize: 8,
                cellPadding: 2,
                overflow: 'linebreak'
            },
            headStyles: {
                fillColor: [99, 102, 241],
                textColor: [255, 255, 255],
                fontStyle: 'bold'
            },
            columnStyles: {
                0: { cellWidth: 20, halign: 'center' },
                1: { cellWidth: 50, font: 'courier' },
                2: { cellWidth: 15, halign: 'center' },
                3: { cellWidth: 25 },
                4: { cellWidth: 60 },
                5: { cellWidth: 20, font: 'courier', halign: 'center' }
            },
            didDrawCell: (data: any) => {
                // Color-code severity column
                if (data.section === 'body' && data.column.index === 0) {
                    const severity = allIssues[data.row.index]?.severity;
                    const color = this.getSeverityColor(severity);
                    doc.setFillColor(...color);
                    doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');
                    doc.setTextColor(255, 255, 255);
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.text(
                        this.getSeveritySymbol(severity),
                        data.cell.x + data.cell.width / 2,
                        data.cell.y + data.cell.height / 2 + 2,
                        { align: 'center' }
                    );
                }
            }
        });

        return (doc as any).lastAutoTable.finalY || startY + 100;
    }

    /**
     * Add file-by-file breakdown section
     */
    private addFileBreakdown(doc: jsPDF, diagnostics: Record<string, PDFReportDiagnostic[]>): void {
        let yPos = this.margin + 15;

        // Title
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(17, 24, 39);
        doc.text('File Breakdown', this.margin, yPos);
        yPos += 10;

        const sortedFiles = Object.entries(diagnostics)
            .sort((a, b) => b[1].length - a[1].length)
            .slice(0, 15); // Top 15 files

        doc.setFontSize(9);
        for (const [file, issues] of sortedFiles) {
            // Check if we need a new page
            if (yPos > this.pageHeight - this.margin - 30) {
                doc.addPage();
                yPos = this.margin + 15;
            }

            // File name
            doc.setFont('courier', 'bold');
            doc.setTextColor(17, 24, 39);
            doc.text(this.truncateText(this.shortenPath(file), 70), this.margin, yPos);
            yPos += 5;

            // Issue counts
            const severityCounts = {
                critical: issues.filter(i => i.severity === 'critical').length,
                high: issues.filter(i => i.severity === 'high').length,
                medium: issues.filter(i => i.severity === 'medium').length,
                low: issues.filter(i => i.severity === 'low').length
            };

            doc.setFont('helvetica', 'normal');
            doc.setTextColor(75, 85, 99);
            const countsText = `Critical: ${severityCounts.critical} | High: ${severityCounts.high} | Medium: ${severityCounts.medium} | Low: ${severityCounts.low}`;
            doc.text(countsText, this.margin + 5, yPos);
            yPos += 8;
        }
    }

    /**
     * Calculate statistics from diagnostics
     */
    private calculateStats(diagnostics: Record<string, PDFReportDiagnostic[]>): {
        totalIssues: number;
        criticalCount: number;
        highCount: number;
        mediumCount: number;
        lowCount: number;
        filesAffected: number;
        topIssueTypes: Array<{ source: string; count: number }>;
        mostAffectedFiles: Array<{ file: string; count: number }>;
    } {
        const allIssues = Object.values(diagnostics).flat();
        const filesAffected = Object.keys(diagnostics).length;

        const severityCounts = {
            critical: allIssues.filter(d => d.severity === 'critical').length,
            high: allIssues.filter(d => d.severity === 'high').length,
            medium: allIssues.filter(d => d.severity === 'medium').length,
            low: allIssues.filter(d => d.severity === 'low').length
        };

        // Top issue types
        const sourceMap = new Map<string, number>();
        for (const issue of allIssues) {
            sourceMap.set(issue.source, (sourceMap.get(issue.source) || 0) + 1);
        }
        const topIssueTypes = Array.from(sourceMap.entries())
            .map(([source, count]) => ({ source, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 5);

        // Most affected files
        const fileMap = new Map<string, number>();
        for (const [file, issues] of Object.entries(diagnostics)) {
            fileMap.set(file, issues.length);
        }
        const mostAffectedFiles = Array.from(fileMap.entries())
            .map(([file, count]) => ({ file, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);

        return {
            totalIssues: allIssues.length,
            criticalCount: severityCounts.critical,
            highCount: severityCounts.high,
            mediumCount: severityCounts.medium,
            lowCount: severityCounts.low,
            filesAffected,
            topIssueTypes,
            mostAffectedFiles
        };
    }

    /**
     * Calculate health score (0-100)
     */
    private calculateHealthScore(stats: ReturnType<typeof this.calculateStats>): number {
        const { totalIssues, criticalCount, highCount, mediumCount, lowCount } = stats;
        if (totalIssues === 0) return 100;

        const penalty = (criticalCount * 10) + (highCount * 5) + (mediumCount * 2) + (lowCount * 1);
        const maxScore = 100;
        const score = Math.max(0, maxScore - penalty);
        return Math.round(score);
    }

    /**
     * Get color for health score
     */
    private getHealthColor(score: number): [number, number, number] {
        if (score >= 80) return [16, 185, 129]; // Green
        if (score >= 60) return [245, 158, 11]; // Amber
        return [220, 38, 38]; // Red
    }

    /**
     * Get color for severity
     */
    private getSeverityColor(severity: string): [number, number, number] {
        switch (severity) {
            case 'critical': return [220, 38, 38];
            case 'high': return [245, 158, 11];
            case 'medium': return [59, 130, 246];
            case 'low': return [16, 185, 129];
            default: return [107, 114, 128];
        }
    }

    /**
     * Get symbol for severity
     */
    private getSeveritySymbol(severity: string): string {
        switch (severity) {
            case 'critical': return 'ðŸ”´ CRIT';
            case 'high': return 'ðŸŸ  HIGH';
            case 'medium': return 'ðŸ”µ MED';
            case 'low': return 'ðŸŸ¢ LOW';
            default: return 'âšª UNK';
        }
    }

    /**
     * Shorten file path for display
     */
    private shortenPath(filePath: string): string {
        const segments = filePath.split(/[/\\]/);
        if (segments.length <= 3) return filePath;
        return `.../${segments.slice(-3).join('/')}`;
    }

    /**
     * Format ISO timestamp
     */
    private formatTimestamp(timestamp: string): string {
        const date = new Date(timestamp);
        return date.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    /**
     * Truncate text to max length
     */
    private truncateText(text: string, maxLength: number): string {
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength - 3) + '...';
    }
}
