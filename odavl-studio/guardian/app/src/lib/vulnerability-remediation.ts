/**
 * Vulnerability Remediation System for ODAVL Guardian
 * 
 * Automated vulnerability tracking, prioritization, and remediation management.
 * Integrates with DAST scanner and penetration testing results.
 * 
 * Features:
 * - Vulnerability database
 * - SLA tracking
 * - Remediation workflow
 * - Risk scoring
 * - Auto-fix suggestions
 * - Compliance reporting
 */

export interface Vulnerability {
    id: string;
    source: 'dast' | 'pentest' | 'sast' | 'manual' | 'dependency';
    name: string;
    description: string;
    severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
    category: string;
    url?: string;
    file?: string;
    line?: number;
    cwe?: number;
    cvss?: number;
    discoveredAt: Date;
    status: 'new' | 'triaged' | 'in-progress' | 'fixed' | 'accepted' | 'false-positive';
    assignee?: string;
    dueDate?: Date;
    evidence?: string;
    remediation?: string;
    affectedVersions?: string[];
    fixedInVersion?: string;
}

export interface RemediationTask {
    id: string;
    vulnerabilityId: string;
    title: string;
    description: string;
    priority: 'immediate' | 'urgent' | 'normal' | 'low';
    estimatedEffort: string; // e.g., "2-4 hours"
    status: 'pending' | 'in-progress' | 'completed' | 'blocked';
    assignee?: string;
    steps: RemediationStep[];
    createdAt: Date;
    startedAt?: Date;
    completedAt?: Date;
    blockers?: string[];
    testingPlan?: string;
    verificationCriteria?: string[];
}

export interface RemediationStep {
    id: string;
    order: number;
    description: string;
    status: 'pending' | 'completed';
    completedAt?: Date;
    notes?: string;
    codeChanges?: CodeChange[];
}

export interface CodeChange {
    file: string;
    lineStart: number;
    lineEnd: number;
    before: string;
    after: string;
    type: 'add' | 'modify' | 'remove';
}

export interface VulnerabilityStats {
    total: number;
    byStatus: Record<Vulnerability['status'], number>;
    bySeverity: Record<Vulnerability['severity'], number>;
    bySource: Record<Vulnerability['source'], number>;
    overdue: number;
    averageTimeToFix: number; // days
    fixRate: number; // percentage
}

export interface ComplianceReport {
    reportId: string;
    generatedAt: Date;
    period: { start: Date; end: Date };
    stats: VulnerabilityStats;
    slaCompliance: {
        critical: { total: number; onTime: number; percentage: number };
        high: { total: number; onTime: number; percentage: number };
        medium: { total: number; onTime: number; percentage: number };
        low: { total: number; onTime: number; percentage: number };
    };
    topVulnerabilities: Vulnerability[];
    recommendations: string[];
}

/**
 * Vulnerability Remediation Manager
 */
export class VulnerabilityRemediationManager {
    private vulnerabilities: Map<string, Vulnerability> = new Map();
    private remediationTasks: Map<string, RemediationTask> = new Map();

    // SLA in hours
    private readonly SLA_HOURS = {
        critical: 24,
        high: 72,
        medium: 168, // 1 week
        low: 720, // 30 days
        info: 2160, // 90 days
    };

    /**
     * Add a vulnerability to the system
     */
    addVulnerability(vuln: Omit<Vulnerability, 'id' | 'discoveredAt' | 'status'>): Vulnerability {
        const vulnerability: Vulnerability = {
            id: this.generateVulnId(),
            ...vuln,
            discoveredAt: new Date(),
            status: 'new',
        };

        this.vulnerabilities.set(vulnerability.id, vulnerability);

        // Auto-create remediation task for high/critical
        if (vulnerability.severity === 'critical' || vulnerability.severity === 'high') {
            this.createRemediationTask(vulnerability);
        }

        console.log(`[Remediation] Added vulnerability: ${vulnerability.name} (${vulnerability.severity})`);
        return vulnerability;
    }

    /**
     * Create remediation task for a vulnerability
     */
    createRemediationTask(vulnerability: Vulnerability): RemediationTask {
        const priority = this.determinePriority(vulnerability);
        const estimatedEffort = this.estimateEffort(vulnerability);
        const steps = this.generateRemediationSteps(vulnerability);

        const task: RemediationTask = {
            id: this.generateTaskId(),
            vulnerabilityId: vulnerability.id,
            title: `Fix: ${vulnerability.name}`,
            description: vulnerability.description,
            priority,
            estimatedEffort,
            status: 'pending',
            steps,
            createdAt: new Date(),
            testingPlan: this.generateTestingPlan(vulnerability),
            verificationCriteria: this.generateVerificationCriteria(vulnerability),
        };

        this.remediationTasks.set(task.id, task);
        console.log(`[Remediation] Created task: ${task.title}`);
        return task;
    }

    /**
     * Determine remediation priority
     */
    private determinePriority(vulnerability: Vulnerability): RemediationTask['priority'] {
        const hoursUntilDue = this.getHoursUntilDue(vulnerability);

        if (vulnerability.severity === 'critical') return 'immediate';
        if (vulnerability.severity === 'high' && hoursUntilDue < 24) return 'immediate';
        if (vulnerability.severity === 'high') return 'urgent';
        if (vulnerability.severity === 'medium' && hoursUntilDue < 48) return 'urgent';
        if (vulnerability.severity === 'medium') return 'normal';
        return 'low';
    }

    /**
     * Get hours until vulnerability is due
     */
    private getHoursUntilDue(vulnerability: Vulnerability): number {
        const slaHours = this.SLA_HOURS[vulnerability.severity];
        const discoveredTime = vulnerability.discoveredAt.getTime();
        const dueTime = discoveredTime + (slaHours * 60 * 60 * 1000);
        const now = Date.now();
        return Math.max(0, (dueTime - now) / (60 * 60 * 1000));
    }

    /**
     * Estimate remediation effort
     */
    private estimateEffort(vulnerability: Vulnerability): string {
        const effortByCategory: Record<string, string> = {
            'SQL Injection': '4-8 hours',
            'XSS': '2-4 hours',
            'CSRF': '2-4 hours',
            'IDOR': '4-6 hours',
            'Authentication': '4-8 hours',
            'Authorization': '4-6 hours',
            'Session Management': '2-4 hours',
            'Cryptography': '4-8 hours',
            'Configuration': '1-2 hours',
            'Information Disclosure': '1-3 hours',
            'Business Logic': '4-8 hours',
            'API Security': '2-4 hours',
        };

        return effortByCategory[vulnerability.category] || '2-4 hours';
    }

    /**
     * Generate remediation steps
     */
    private generateRemediationSteps(vulnerability: Vulnerability): RemediationStep[] {
        const steps: RemediationStep[] = [];

        // Common steps for all vulnerabilities
        steps.push({
            id: this.generateStepId(),
            order: 1,
            description: 'Review vulnerability details and understand the attack vector',
            status: 'pending',
        });

        steps.push({
            id: this.generateStepId(),
            order: 2,
            description: 'Reproduce the vulnerability in a test environment',
            status: 'pending',
        });

        // Category-specific steps
        const categorySteps = this.getCategorySpecificSteps(vulnerability);
        categorySteps.forEach((desc, index) => {
            steps.push({
                id: this.generateStepId(),
                order: 3 + index,
                description: desc,
                status: 'pending',
            });
        });

        // Testing and verification steps
        const testingOrder = 3 + categorySteps.length;
        steps.push({
            id: this.generateStepId(),
            order: testingOrder,
            description: 'Write automated tests to verify the fix',
            status: 'pending',
        });

        steps.push({
            id: this.generateStepId(),
            order: testingOrder + 1,
            description: 'Run security scan to confirm vulnerability is fixed',
            status: 'pending',
        });

        steps.push({
            id: this.generateStepId(),
            order: testingOrder + 2,
            description: 'Deploy to staging and verify',
            status: 'pending',
        });

        steps.push({
            id: this.generateStepId(),
            order: testingOrder + 3,
            description: 'Update security documentation',
            status: 'pending',
        });

        return steps;
    }

    /**
     * Get category-specific remediation steps
     */
    private getCategorySpecificSteps(vulnerability: Vulnerability): string[] {
        const stepsByCategory: Record<string, string[]> = {
            'SQL Injection': [
                'Identify all SQL queries using user input',
                'Replace string concatenation with parameterized queries',
                'Add input validation and sanitization',
                'Review database permissions and use least privilege',
            ],
            'XSS': [
                'Identify all user input rendering locations',
                'Implement HTML encoding/escaping',
                'Add Content Security Policy headers',
                'Use auto-escaping template engine',
            ],
            'CSRF': [
                'Implement CSRF token generation',
                'Add CSRF token validation to all state-changing endpoints',
                'Configure SameSite cookie attribute',
                'Verify token on server side',
            ],
            'IDOR': [
                'Implement authorization checks before resource access',
                'Use indirect object references (mapping IDs)',
                'Add logging for authorization failures',
                'Review all API endpoints for similar issues',
            ],
            'Authentication': [
                'Implement rate limiting on authentication endpoints',
                'Add account lockout after failed attempts',
                'Enforce strong password requirements',
                'Implement multi-factor authentication',
            ],
            'Authorization': [
                'Implement role-based access control (RBAC)',
                'Add authorization middleware to all protected routes',
                'Verify user permissions before allowing actions',
                'Review and document access control matrix',
            ],
            'Session Management': [
                'Regenerate session ID after authentication',
                'Set secure cookie flags (Secure, HttpOnly, SameSite)',
                'Implement session timeout',
                'Invalidate session on logout',
            ],
            'Configuration': [
                'Review and update security headers',
                'Disable unnecessary features and endpoints',
                'Update web server configuration',
                'Remove default credentials and test accounts',
            ],
        };

        return stepsByCategory[vulnerability.category] || [
            'Implement recommended fix from security advisory',
            'Add input validation and sanitization',
            'Review similar code for the same vulnerability',
        ];
    }

    /**
     * Generate testing plan
     */
    private generateTestingPlan(vulnerability: Vulnerability): string {
        let plan = '# Testing Plan\n\n';
        plan += '## Unit Tests\n';
        plan += '- Add unit tests that verify the fix\n';
        plan += '- Test edge cases and boundary conditions\n';
        plan += '- Ensure tests fail before fix and pass after fix\n\n';

        plan += '## Integration Tests\n';
        plan += '- Test the fix in the context of the full application\n';
        plan += '- Verify no regressions in related functionality\n\n';

        plan += '## Security Tests\n';
        plan += '- Re-run security scan (DAST/SAST)\n';
        plan += '- Manually test the attack vector\n';
        plan += '- Verify with penetration testing tools\n\n';

        plan += '## Performance Tests\n';
        plan += '- Ensure the fix does not degrade performance\n';
        plan += '- Run load tests if applicable\n\n';

        return plan;
    }

    /**
     * Generate verification criteria
     */
    private generateVerificationCriteria(vulnerability: Vulnerability): string[] {
        return [
            'Security scan shows vulnerability as fixed',
            'Manual testing confirms attack no longer works',
            'All automated tests pass',
            'Code review approved by security team',
            'No performance degradation observed',
            'Documentation updated',
            'Deployed to production and verified',
        ];
    }

    /**
     * Update vulnerability status
     */
    updateVulnerabilityStatus(
        vulnId: string,
        status: Vulnerability['status'],
        notes?: string
    ): void {
        const vuln = this.vulnerabilities.get(vulnId);
        if (!vuln) throw new Error(`Vulnerability ${vulnId} not found`);

        vuln.status = status;
        console.log(`[Remediation] Vulnerability ${vulnId} status updated: ${status}`);

        // Update associated remediation tasks
        const tasks = this.getTasksForVulnerability(vulnId);
        tasks.forEach(task => {
            if (status === 'fixed') {
                task.status = 'completed';
                task.completedAt = new Date();
            } else if (status === 'in-progress') {
                task.status = 'in-progress';
                task.startedAt = task.startedAt || new Date();
            }
        });
    }

    /**
     * Get all tasks for a vulnerability
     */
    private getTasksForVulnerability(vulnId: string): RemediationTask[] {
        return Array.from(this.remediationTasks.values()).filter(
            task => task.vulnerabilityId === vulnId
        );
    }

    /**
     * Get overdue vulnerabilities
     */
    getOverdueVulnerabilities(): Vulnerability[] {
        const now = Date.now();
        return Array.from(this.vulnerabilities.values()).filter(vuln => {
            if (vuln.status === 'fixed' || vuln.status === 'accepted') return false;

            const slaHours = this.SLA_HOURS[vuln.severity];
            const dueTime = vuln.discoveredAt.getTime() + (slaHours * 60 * 60 * 1000);
            return now > dueTime;
        });
    }

    /**
     * Get vulnerabilities by severity
     */
    getVulnerabilitiesBySeverity(severity: Vulnerability['severity']): Vulnerability[] {
        return Array.from(this.vulnerabilities.values()).filter(
            vuln => vuln.severity === severity
        );
    }

    /**
     * Get vulnerabilities by status
     */
    getVulnerabilitiesByStatus(status: Vulnerability['status']): Vulnerability[] {
        return Array.from(this.vulnerabilities.values()).filter(
            vuln => vuln.status === status
        );
    }

    /**
     * Get high-priority remediation tasks
     */
    getHighPriorityTasks(): RemediationTask[] {
        return Array.from(this.remediationTasks.values())
            .filter(task => task.priority === 'immediate' || task.priority === 'urgent')
            .filter(task => task.status !== 'completed')
            .sort((a, b) => {
                // Sort by priority then creation date
                const priorityOrder = { immediate: 0, urgent: 1, normal: 2, low: 3 };
                const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
                if (priorityDiff !== 0) return priorityDiff;
                return a.createdAt.getTime() - b.createdAt.getTime();
            });
    }

    /**
     * Get vulnerability statistics
     */
    getStats(): VulnerabilityStats {
        const vulns = Array.from(this.vulnerabilities.values());

        const byStatus: Record<Vulnerability['status'], number> = {
            new: 0, triaged: 0, 'in-progress': 0, fixed: 0, accepted: 0, 'false-positive': 0,
        };

        const bySeverity: Record<Vulnerability['severity'], number> = {
            critical: 0, high: 0, medium: 0, low: 0, info: 0,
        };

        const bySource: Record<Vulnerability['source'], number> = {
            dast: 0, pentest: 0, sast: 0, manual: 0, dependency: 0,
        };

        vulns.forEach(vuln => {
            byStatus[vuln.status]++;
            bySeverity[vuln.severity]++;
            bySource[vuln.source]++;
        });

        const overdue = this.getOverdueVulnerabilities().length;

        // Calculate average time to fix
        const fixedVulns = vulns.filter(v => v.status === 'fixed');
        let totalDays = 0;
        fixedVulns.forEach(vuln => {
            const task = this.getTasksForVulnerability(vuln.id)[0];
            if (task?.completedAt) {
                const days = (task.completedAt.getTime() - vuln.discoveredAt.getTime()) / (1000 * 60 * 60 * 24);
                totalDays += days;
            }
        });
        const averageTimeToFix = fixedVulns.length > 0 ? totalDays / fixedVulns.length : 0;

        // Calculate fix rate
        const fixableVulns = vulns.filter(v => v.status !== 'false-positive');
        const fixRate = fixableVulns.length > 0
            ? (byStatus.fixed / fixableVulns.length) * 100
            : 0;

        return {
            total: vulns.length,
            byStatus,
            bySeverity,
            bySource,
            overdue,
            averageTimeToFix: Math.round(averageTimeToFix * 10) / 10,
            fixRate: Math.round(fixRate * 10) / 10,
        };
    }

    /**
     * Generate compliance report
     */
    generateComplianceReport(period: { start: Date; end: Date }): ComplianceReport {
        const vulns = Array.from(this.vulnerabilities.values()).filter(
            vuln => vuln.discoveredAt >= period.start && vuln.discoveredAt <= period.end
        );

        const stats = this.getStats();

        // Calculate SLA compliance
        const slaCompliance = {
            critical: this.calculateSLACompliance('critical', vulns),
            high: this.calculateSLACompliance('high', vulns),
            medium: this.calculateSLACompliance('medium', vulns),
            low: this.calculateSLACompliance('low', vulns),
        };

        // Get top vulnerabilities by severity
        const topVulnerabilities = vulns
            .filter(v => v.severity === 'critical' || v.severity === 'high')
            .slice(0, 10);

        // Generate recommendations
        const recommendations = this.generateRecommendations(stats, slaCompliance);

        return {
            reportId: this.generateReportId(),
            generatedAt: new Date(),
            period,
            stats,
            slaCompliance,
            topVulnerabilities,
            recommendations,
        };
    }

    /**
     * Calculate SLA compliance for a severity level
     */
    private calculateSLACompliance(
        severity: Vulnerability['severity'],
        vulns: Vulnerability[]
    ): { total: number; onTime: number; percentage: number } {
        const severityVulns = vulns.filter(v => v.severity === severity);
        const total = severityVulns.length;

        if (total === 0) {
            return { total: 0, onTime: 0, percentage: 100 };
        }

        const slaHours = this.SLA_HOURS[severity];
        let onTime = 0;

        severityVulns.forEach(vuln => {
            if (vuln.status === 'fixed' || vuln.status === 'accepted') {
                const task = this.getTasksForVulnerability(vuln.id)[0];
                if (task?.completedAt) {
                    const hoursToFix = (task.completedAt.getTime() - vuln.discoveredAt.getTime()) / (1000 * 60 * 60);
                    if (hoursToFix <= slaHours) {
                        onTime++;
                    }
                }
            } else {
                // Still open, check if within SLA
                const hoursOpen = (Date.now() - vuln.discoveredAt.getTime()) / (1000 * 60 * 60);
                if (hoursOpen <= slaHours) {
                    onTime++;
                }
            }
        });

        const percentage = Math.round((onTime / total) * 100);
        return { total, onTime, percentage };
    }

    /**
     * Generate recommendations based on stats
     */
    private generateRecommendations(
        stats: VulnerabilityStats,
        slaCompliance: ComplianceReport['slaCompliance']
    ): string[] {
        const recommendations: string[] = [];

        // Check overdue vulnerabilities
        if (stats.overdue > 0) {
            recommendations.push(
                `‚ö†Ô∏è ${stats.overdue} vulnerabilities are overdue. Allocate additional resources to remediation.`
            );
        }

        // Check critical vulnerabilities
        if (stats.bySeverity.critical > 0) {
            recommendations.push(
                `üî¥ ${stats.bySeverity.critical} critical vulnerabilities require immediate attention. These should be fixed within 24 hours.`
            );
        }

        // Check SLA compliance
        if (slaCompliance.critical.percentage < 90) {
            recommendations.push(
                `üìâ Critical vulnerability SLA compliance is ${slaCompliance.critical.percentage}%. Target is 95%+. Review resource allocation.`
            );
        }

        if (slaCompliance.high.percentage < 85) {
            recommendations.push(
                `üìâ High vulnerability SLA compliance is ${slaCompliance.high.percentage}%. Target is 90%+. Consider increasing team capacity.`
            );
        }

        // Check average time to fix
        if (stats.averageTimeToFix > 14) {
            recommendations.push(
                `‚è±Ô∏è Average time to fix is ${stats.averageTimeToFix} days. Consider automation and security tooling to reduce this.`
            );
        }

        // Check fix rate
        if (stats.fixRate < 70) {
            recommendations.push(
                `üìä Current fix rate is ${stats.fixRate}%. Target is 80%+. Review backlog and prioritization process.`
            );
        }

        // Check vulnerability sources
        if (stats.bySource.dast > stats.bySource.sast * 2) {
            recommendations.push(
                `üîç DAST finding significantly more issues than SAST. Consider improving SAST coverage and running it earlier in development.`
            );
        }

        // General recommendations
        if (recommendations.length === 0) {
            recommendations.push(
                '‚úÖ Security posture is good. Continue regular security scanning and maintain current remediation pace.'
            );
        }

        recommendations.push(
            'üîÑ Schedule quarterly penetration tests to identify additional vulnerabilities.'
        );

        recommendations.push(
            'üìö Conduct security training for development team to reduce future vulnerabilities.'
        );

        return recommendations;
    }

    /**
     * Generate remediation report (markdown)
     */
    generateRemediationReport(): string {
        const stats = this.getStats();
        const overdue = this.getOverdueVulnerabilities();
        const highPriority = this.getHighPriorityTasks();

        let report = '# Vulnerability Remediation Report\n\n';
        report += `**Generated:** ${new Date().toISOString()}\n\n`;

        report += '## Summary\n\n';
        report += `- **Total Vulnerabilities:** ${stats.total}\n`;
        report += `- **Critical:** ${stats.bySeverity.critical}\n`;
        report += `- **High:** ${stats.bySeverity.high}\n`;
        report += `- **Medium:** ${stats.bySeverity.medium}\n`;
        report += `- **Low:** ${stats.bySeverity.low}\n`;
        report += `- **Overdue:** ${stats.overdue}\n`;
        report += `- **Average Time to Fix:** ${stats.averageTimeToFix} days\n`;
        report += `- **Fix Rate:** ${stats.fixRate}%\n\n`;

        if (overdue.length > 0) {
            report += '## ‚ö†Ô∏è Overdue Vulnerabilities\n\n';
            overdue.slice(0, 10).forEach(vuln => {
                const hoursOverdue = Math.round(
                    (Date.now() - vuln.discoveredAt.getTime()) / (1000 * 60 * 60) - this.SLA_HOURS[vuln.severity]
                );
                report += `### ${vuln.name}\n`;
                report += `- **Severity:** ${vuln.severity}\n`;
                report += `- **Status:** ${vuln.status}\n`;
                report += `- **Overdue by:** ${hoursOverdue} hours\n`;
                report += `- **Discovered:** ${vuln.discoveredAt.toISOString()}\n\n`;
            });
        }

        if (highPriority.length > 0) {
            report += '## üî• High Priority Tasks\n\n';
            highPriority.slice(0, 10).forEach(task => {
                report += `### ${task.title}\n`;
                report += `- **Priority:** ${task.priority}\n`;
                report += `- **Status:** ${task.status}\n`;
                report += `- **Estimated Effort:** ${task.estimatedEffort}\n`;
                if (task.assignee) report += `- **Assignee:** ${task.assignee}\n`;
                report += `- **Steps:** ${task.steps.filter(s => s.status === 'completed').length}/${task.steps.length} completed\n\n`;
            });
        }

        report += '## Status Breakdown\n\n';
        Object.entries(stats.byStatus).forEach(([status, count]) => {
            if (count > 0) {
                report += `- **${status}:** ${count}\n`;
            }
        });

        report += '\n## Recommendations\n\n';
        const complianceReport = this.generateComplianceReport({
            start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
            end: new Date(),
        });
        complianceReport.recommendations.forEach(rec => {
            report += `${rec}\n\n`;
        });

        return report;
    }

    /**
     * Generate auto-fix code suggestion
     */
    generateAutoFix(vulnerability: Vulnerability): string | null {
        // Only generate auto-fix for common, low-risk fixes
        const autoFixableCategories = ['Configuration', 'Information Disclosure'];

        if (!autoFixableCategories.includes(vulnerability.category)) {
            return null;
        }

        // Generate fix based on vulnerability name
        if (vulnerability.name.includes('Security Headers')) {
            return this.generateSecurityHeadersFix();
        }

        if (vulnerability.name.includes('Cookie')) {
            return this.generateCookieSecurityFix();
        }

        if (vulnerability.name.includes('CORS')) {
            return this.generateCORSFix();
        }

        return null;
    }

    /**
     * Generate security headers fix
     */
    private generateSecurityHeadersFix(): string {
        return `// Add security headers middleware (Express.js)
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
}));

// Or manually set headers
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  next();
});`;
    }

    /**
     * Generate cookie security fix
     */
    private generateCookieSecurityFix(): string {
        return `// Secure cookie configuration (Express.js)
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true, // Only send over HTTPS
    httpOnly: true, // Not accessible via JavaScript
    sameSite: 'strict', // CSRF protection
    maxAge: 1000 * 60 * 60 * 8, // 8 hours
  },
}));`;
    }

    /**
     * Generate CORS fix
     */
    private generateCORSFix(): string {
        return `// Secure CORS configuration (Express.js)
import cors from 'cors';

const allowedOrigins = [
  'https://app.guardian.app',
  'https://guardian.app',
];

app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));`;
    }

    /**
     * Generate IDs
     */
    private generateVulnId(): string {
        return `VULN-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`;
    }

    private generateTaskId(): string {
        return `TASK-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`;
    }

    private generateStepId(): string {
        return `STEP-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`;
    }

    private generateReportId(): string {
        return `REPORT-${Date.now()}-${Math.random().toString(36).substring(7).toUpperCase()}`;
    }

    /**
     * Export vulnerabilities as JSON
     */
    exportVulnerabilities(): string {
        return JSON.stringify(
            Array.from(this.vulnerabilities.values()),
            null,
            2
        );
    }

    /**
     * Import vulnerabilities from JSON
     */
    importVulnerabilities(json: string): void {
        const vulns = JSON.parse(json) as Vulnerability[];
        vulns.forEach(vuln => {
            this.vulnerabilities.set(vuln.id, vuln);
        });
    }
}

/**
 * Example usage:
 * 
 * const manager = new VulnerabilityRemediationManager();
 * 
 * // Add vulnerability from DAST scan
 * const vuln = manager.addVulnerability({
 *   source: 'dast',
 *   name: 'SQL Injection',
 *   description: 'User input not properly sanitized',
 *   severity: 'critical',
 *   category: 'SQL Injection',
 *   url: 'https://app.guardian.test/api/users',
 *   cwe: 89,
 *   cvss: 9.8,
 * });
 * 
 * // Get remediation tasks
 * const tasks = manager.getHighPriorityTasks();
 * console.log('High priority tasks:', tasks);
 * 
 * // Update status
 * manager.updateVulnerabilityStatus(vuln.id, 'in-progress');
 * 
 * // Generate report
 * console.log(manager.generateRemediationReport());
 * 
 * // Get compliance report
 * const report = manager.generateComplianceReport({
 *   start: new Date('2025-01-01'),
 *   end: new Date('2025-12-31'),
 * });
 */
