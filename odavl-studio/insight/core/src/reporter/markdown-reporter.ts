/**
 * Markdown Report Generator for ODAVL Insight
 * Generates summary reports ready for GitHub/Slack/Email
 */

import type { AnalysisResult, EnhancedIssue } from './html-reporter.js';

export class MarkdownReporter {
  generate(result: AnalysisResult): string {
    const severityCounts = this.calculateSeverityCounts(result.issues);
    const topIssues = this.getTopIssues(result.issues, 10);
    
    return `# ðŸ§  ODAVL Insight Report

**Workspace:** \`${result.workspace}\`  
**Generated:** ${result.timestamp}  
**Duration:** ${result.duration}s  
**Total Issues:** ${result.totalIssues}

---

## ðŸ“Š Summary by Severity

| Severity | Count | Percentage |
|----------|-------|------------|
| ðŸš¨ Critical | ${severityCounts.critical} | ${this.percentage(severityCounts.critical, result.totalIssues)}% |
| âš ï¸ High | ${severityCounts.high} | ${this.percentage(severityCounts.high, result.totalIssues)}% |
| ðŸ“Š Medium | ${severityCounts.medium} | ${this.percentage(severityCounts.medium, result.totalIssues)}% |
| â„¹ï¸ Low | ${severityCounts.low} | ${this.percentage(severityCounts.low, result.totalIssues)}% |

---

## ðŸ” Summary by Detector

| Detector | Critical | High | Medium | Low | Total |
|----------|----------|------|--------|-----|-------|
${result.detectors.map(d => 
  `| ${d.icon} ${d.name} | ${d.severity.critical} | ${d.severity.high} | ${d.severity.medium} | ${d.severity.low} | **${d.count}** |`
).join('\n')}

---

## ðŸš¨ Top 10 Priority Issues

${topIssues.map((issue, i) => this.formatIssue(issue, i + 1)).join('\n\n')}

---

## ðŸ’¡ Recommendations

### Immediate Actions (Next 24 hours)

${this.getImmediateActions(result.issues)}

### Short-term (This Week)

${this.getShortTermActions(result.issues)}

### Long-term (This Month)

${this.getLongTermActions(result.issues)}

---

## ðŸ“ˆ Progress Tracking

- [ ] Fix ${severityCounts.critical} critical issues
- [ ] Fix ${severityCounts.high} high-priority issues
- [ ] Review ${severityCounts.medium} medium-priority issues
- [ ] Address ${severityCounts.low} low-priority issues

---

## ðŸ“Š Quality Metrics

- **Critical Issues Density:** ${(severityCounts.critical / result.totalIssues * 100).toFixed(1)}%
- **High Confidence Issues:** ${result.issues.filter(i => i.confidence >= 90).length}
- **Code Health Score:** ${this.calculateHealthScore(severityCounts, result.totalIssues)}/100

---

*Generated by **ODAVL Insight v2.0** ðŸ§ *  
*Professional Code Analysis with Machine Learning*
`;
  }
  
  private calculateSeverityCounts(issues: EnhancedIssue[]) {
    return {
      critical: issues.filter(i => i.priority === 'critical').length,
      high: issues.filter(i => i.priority === 'high').length,
      medium: issues.filter(i => i.priority === 'medium').length,
      low: issues.filter(i => i.priority === 'low').length,
    };
  }
  
  private getTopIssues(issues: EnhancedIssue[], count: number): EnhancedIssue[] {
    return issues
      .filter(i => i.priority === 'critical' || i.priority === 'high')
      .sort((a, b) => {
        const priorityOrder: { [key: string]: number } = { critical: 0, high: 1 };
        if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
          return priorityOrder[a.priority] - priorityOrder[b.priority];
        }
        return b.confidence - a.confidence;
      })
      .slice(0, count);
  }
  
  private formatIssue(issue: EnhancedIssue, index: number): string {
    const badge = issue.priority === 'critical' ? 'ðŸš¨ **CRITICAL**' : 'âš ï¸ **HIGH**';
    
    return `### ${index}. ${badge} ${issue.message}

- **Detector:** ${issue.detector}
- **Confidence:** ${issue.confidence}%
${issue.file ? `- **Location:** \`${issue.file}${issue.line ? `:${issue.line}` : ''}\`` : ''}
${issue.suggestion ? `- **ðŸ’¡ Suggestion:** ${issue.suggestion}` : ''}`;
  }
  
  private getImmediateActions(issues: EnhancedIssue[]): string {
    const critical = issues.filter(i => i.priority === 'critical');
    if (critical.length === 0) {
      return '- âœ… No critical issues detected';
    }
    
    const uniqueDetectors = new Set(critical.map(i => i.detector));
    return Array.from(uniqueDetectors)
      .slice(0, 3)
      .map(detector => {
        const count = critical.filter(i => i.detector === detector).length;
        return `- Fix ${count} critical ${detector} issue${count > 1 ? 's' : ''}`;
      })
      .join('\n');
  }
  
  private getShortTermActions(issues: EnhancedIssue[]): string {
    const high = issues.filter(i => i.priority === 'high');
    if (high.length === 0) {
      return '- âœ… No high-priority issues detected';
    }
    
    const uniqueDetectors = new Set(high.map(i => i.detector));
    return Array.from(uniqueDetectors)
      .slice(0, 3)
      .map(detector => {
        const count = high.filter(i => i.detector === detector).length;
        return `- Address ${count} high-priority ${detector} issue${count > 1 ? 's' : ''}`;
      })
      .join('\n');
  }
  
  private getLongTermActions(issues: EnhancedIssue[]): string {
    const medium = issues.filter(i => i.priority === 'medium');
    if (medium.length === 0) {
      return '- âœ… No medium-priority issues detected';
    }
    
    return [
      `- Review and refactor ${medium.length} medium-priority issues`,
      '- Implement automated testing for resolved issues',
      '- Update coding standards and documentation',
    ].join('\n');
  }
  
  private percentage(count: number, total: number): string {
    if (total === 0) return '0.0';
    return ((count / total) * 100).toFixed(1);
  }
  
  private calculateHealthScore(
    severityCounts: { critical: number; high: number; medium: number; low: number },
    total: number
  ): number {
    if (total === 0) return 100;
    
    const score = 100 -
      (severityCounts.critical * 10) -
      (severityCounts.high * 5) -
      (severityCounts.medium * 2) -
      (severityCounts.low * 0.5);
    
    return Math.max(0, Math.round(score));
  }
}
