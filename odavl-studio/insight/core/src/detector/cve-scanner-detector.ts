/**
 * CVE Scanner Detector - Advanced Security Analysis
 * Integrates CVE database scanning with ODAVL Insight
 */

import { CVEScanner, CVEScanResult as CoreCVEScanResult, CVEFinding, CVSSSeverity } from '../security/cve-scanner.js';

export interface CVEScanResult {
  name: string;
  issues: CVEIssue[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    autoFixable: number;
  };
}

export interface CVEIssue {
  type: 'cve-vulnerability';
  severity: 'critical' | 'high' | 'medium' | 'low';
  message: string;
  package: string;
  version: string;
  cveId: string;
  cvss?: number;
  riskScore: number;
  description: string;
  fixAvailable: boolean;
  suggestedVersion?: string;
  fixCommand?: string;
  references: string[];
  publishedDate: string;
}

export class CVEScannerDetector {
  private workspaceRoot: string;

  constructor(workspaceRoot: string) {
    this.workspaceRoot = workspaceRoot;
  }

  /**
   * Detect CVE vulnerabilities
   */
  async detect(targetPath?: string): Promise<CVEScanResult> {
    // Use provided path or constructor path
    const scanPath = targetPath || this.workspaceRoot;
    
    // Create CVEScanner instance with proper config
    const scanner = new CVEScanner({
      rootPath: scanPath,
      packageManager: 'auto', // Auto-detect
      minSeverity: CVSSSeverity.LOW,
      includeDev: false, // Only production dependencies for security
      skipAuditFix: true, // Don't auto-fix, just report
      osvEnabled: true, // Enable OSV database
      timeout: 60000
    });
    
    // Run scan
    const scanResult: CoreCVEScanResult = await scanner.scan();
    
    // Convert to detector format
    const issues = this.convertToIssues(scanResult.findings);

    return {
      name: 'CVE Scanner',
      issues,
      summary: this.calculateSummary(issues),
    };
  }

  /**
   * Convert CVE findings to detector issues
   */
  private convertToIssues(findings: CVEFinding[]): CVEIssue[] {
    const issues: CVEIssue[] = [];

    for (const finding of findings) {
      // Calculate risk score (0-100 based on CVSS and exploitability)
      const baseScore = finding.cvssScore * 10; // 0-100
      const exploitBonus = finding.exploitAvailable ? 20 : 0;
      const riskScore = Math.min(100, baseScore + exploitBonus);

      issues.push({
        type: 'cve-vulnerability',
        severity: finding.severity as 'critical' | 'high' | 'medium' | 'low',
        message: `${finding.id}: ${finding.title}`,
        package: finding.package,
        version: finding.installedVersion,
        cveId: finding.id,
        cvss: finding.cvssScore,
        riskScore,
        description: finding.description,
        fixAvailable: finding.patchAvailable,
        suggestedVersion: finding.fixedVersion,
        fixCommand: finding.fixedVersion 
          ? `npm install ${finding.package}@${finding.fixedVersion}`
          : undefined,
        references: finding.references,
        publishedDate: finding.publishedDate.toISOString(),
      });
    }

    return issues.sort((a, b) => b.riskScore - a.riskScore);
  }

  /**
   * Calculate summary statistics
   */
  private calculateSummary(issues: CVEIssue[]) {
    return {
      total: issues.length,
      critical: issues.filter(i => i.severity === 'critical').length,
      high: issues.filter(i => i.severity === 'high').length,
      medium: issues.filter(i => i.severity === 'medium').length,
      low: issues.filter(i => i.severity === 'low').length,
      autoFixable: issues.filter(i => i.fixAvailable).length,
    };
  }

  /**
   * Get fix commands for all auto-fixable vulnerabilities
   */
  getFixCommands(result: CVEScanResult): string[] {
    return result.issues
      .filter(issue => issue.fixCommand)
      .map(issue => issue.fixCommand!);
  }
}
