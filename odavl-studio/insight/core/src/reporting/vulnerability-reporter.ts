/**
 * Vulnerability Reporter - Generate CVE reports with CVSS scoring
 * 
 * Purpose: Professional vulnerability assessment reports
 * Week 30: Security Reporting (File 2/3)
 * 
 * Report Sections:
 * - Executive Summary (risk overview, critical stats)
 * - Vulnerability Inventory (detailed CVE list)
 * - Remediation Plan (prioritized fix recommendations)
 * - Risk Assessment (CVSS scores, exploit probability)
 * - Compliance Impact (regulatory requirements)
 * 
 * Report Formats:
 * - PDF (executive summary)
 * - HTML (interactive dashboard)
 * - JSON (machine-readable)
 * - SARIF (integration with IDEs)
 * - CSV (spreadsheet import)
 * 
 * @module @odavl-studio/core/reporting/vulnerability-reporter
 */

import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Vulnerability severity
 */
export enum VulnerabilitySeverity {
  CRITICAL = 'CRITICAL',
  HIGH = 'HIGH',
  MEDIUM = 'MEDIUM',
  LOW = 'LOW',
  INFO = 'INFO'
}

/**
 * CVSS version
 */
export enum CVSSVersion {
  V2 = 'CVSSv2',
  V3 = 'CVSSv3',
  V3_1 = 'CVSSv3.1',
  V4 = 'CVSSv4'
}

/**
 * Exploit maturity
 */
export enum ExploitMaturity {
  NOT_DEFINED = 'NOT_DEFINED',
  UNPROVEN = 'UNPROVEN',
  PROOF_OF_CONCEPT = 'PROOF_OF_CONCEPT',
  FUNCTIONAL = 'FUNCTIONAL',
  HIGH = 'HIGH'
}

/**
 * Vulnerability finding (detailed)
 */
export interface VulnerabilityFinding {
  id: string; // CVE-2024-12345
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  cvssScore: number;
  cvssVersion: CVSSVersion;
  cvssVector: string;
  cwe?: string[]; // CWE-79, CWE-89
  epssScore?: number; // EPSS (Exploit Prediction Scoring System) 0-1
  exploitMaturity?: ExploitMaturity;
  package: string;
  version: string;
  fixedIn?: string;
  patchAvailable: boolean;
  affectedVersions: string[];
  publishedDate: Date;
  lastModifiedDate: Date;
  references: string[];
  recommendations: string[];
  attackVector?: string; // NETWORK, ADJACENT, LOCAL, PHYSICAL
  attackComplexity?: string; // LOW, HIGH
  privilegesRequired?: string; // NONE, LOW, HIGH
  userInteraction?: string; // NONE, REQUIRED
  scope?: string; // UNCHANGED, CHANGED
  confidentialityImpact?: string; // NONE, LOW, HIGH
  integrityImpact?: string; // NONE, LOW, HIGH
  availabilityImpact?: string; // NONE, LOW, HIGH
}

/**
 * Remediation action
 */
export interface RemediationAction {
  priority: number; // 1 = highest
  vulnerability: string; // CVE ID
  package: string;
  action: 'update' | 'patch' | 'replace' | 'workaround';
  command?: string; // npm update package@version
  effort: 'low' | 'medium' | 'high';
  estimatedHours: number;
  businessImpact: 'none' | 'low' | 'medium' | 'high';
  deadline?: Date;
  assignee?: string;
  status: 'pending' | 'in-progress' | 'completed';
}

/**
 * Risk assessment
 */
export interface RiskAssessment {
  overallRisk: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  likelihood: 'VERY_HIGH' | 'HIGH' | 'MEDIUM' | 'LOW' | 'VERY_LOW';
  impact: 'CATASTROPHIC' | 'SEVERE' | 'MODERATE' | 'MINOR' | 'NEGLIGIBLE';
  riskScore: number; // 0-100
  exploitability: number; // 0-100
  businessRisk: string;
  technicalRisk: string;
  complianceRisk: string;
  mitigatingFactors: string[];
  aggravatingFactors: string[];
}

/**
 * Compliance impact
 */
export interface ComplianceImpact {
  frameworks: Array<{
    name: string; // GDPR, HIPAA, SOC2, PCI-DSS
    affected: boolean;
    requirements: string[];
    penalties: string;
  }>;
  mustFix: boolean; // Regulatory requirement
  deadline?: Date;
  reportingRequired: boolean;
}

/**
 * Vulnerability report
 */
export interface VulnerabilityReport {
  metadata: {
    reportId: string;
    generatedAt: Date;
    generatedBy: string;
    reportVersion: string;
    projectName: string;
    projectVersion: string;
    scanDate: Date;
  };
  executiveSummary: {
    totalVulnerabilities: number;
    bySeverity: Record<VulnerabilitySeverity, number>;
    criticalFindings: number;
    highFindings: number;
    avgCVSS: number;
    highestCVSS: number;
    patchableCount: number;
    requiresAction: number;
    estimatedRemediationTime: number; // hours
    overallRisk: string;
    keyFindings: string[];
  };
  findings: VulnerabilityFinding[];
  remediationPlan: RemediationAction[];
  riskAssessment: RiskAssessment;
  complianceImpact: ComplianceImpact;
  trends: {
    newVulnerabilities: number;
    fixedVulnerabilities: number;
    trendDirection: 'improving' | 'worsening' | 'stable';
  };
  recommendations: string[];
}

/**
 * Vulnerability reporter configuration
 */
export interface VulnerabilityReporterConfig {
  findings: VulnerabilityFinding[];
  projectName: string;
  projectVersion: string;
  includeRemediationPlan?: boolean;
  includeRiskAssessment?: boolean;
  includeComplianceImpact?: boolean;
  includeTrends?: boolean;
  complianceFrameworks?: string[]; // GDPR, HIPAA, SOC2, PCI-DSS
  historicalData?: any; // Previous reports for trends
}

/**
 * Vulnerability Reporter
 */
export class VulnerabilityReporter {
  private config: Required<VulnerabilityReporterConfig>;
  private report: Partial<VulnerabilityReport> = {};

  constructor(config: VulnerabilityReporterConfig) {
    this.config = {
      findings: config.findings,
      projectName: config.projectName,
      projectVersion: config.projectVersion,
      includeRemediationPlan: config.includeRemediationPlan ?? true,
      includeRiskAssessment: config.includeRiskAssessment ?? true,
      includeComplianceImpact: config.includeComplianceImpact ?? true,
      includeTrends: config.includeTrends ?? true,
      complianceFrameworks: config.complianceFrameworks ?? ['GDPR', 'HIPAA', 'SOC2', 'PCI-DSS'],
      historicalData: config.historicalData ?? null
    };
  }

  /**
   * Generate vulnerability report
   */
  async generate(): Promise<VulnerabilityReport> {
    console.log('üìù Generating vulnerability report...');

    // Metadata
    this.report.metadata = {
      reportId: `VULN-${Date.now()}`,
      generatedAt: new Date(),
      generatedBy: 'ODAVL Vulnerability Reporter',
      reportVersion: '1.0.0',
      projectName: this.config.projectName,
      projectVersion: this.config.projectVersion,
      scanDate: new Date()
    };

    // Executive summary
    this.report.executiveSummary = this.generateExecutiveSummary();

    // Findings
    this.report.findings = this.config.findings;

    // Remediation plan
    if (this.config.includeRemediationPlan) {
      this.report.remediationPlan = this.generateRemediationPlan();
    }

    // Risk assessment
    if (this.config.includeRiskAssessment) {
      this.report.riskAssessment = this.generateRiskAssessment();
    }

    // Compliance impact
    if (this.config.includeComplianceImpact) {
      this.report.complianceImpact = this.generateComplianceImpact();
    }

    // Trends
    if (this.config.includeTrends) {
      this.report.trends = this.generateTrends();
    }

    // Recommendations
    this.report.recommendations = this.generateRecommendations();

    return this.report as VulnerabilityReport;
  }

  /**
   * Generate executive summary
   */
  private generateExecutiveSummary(): VulnerabilityReport['executiveSummary'] {
    const findings = this.config.findings;

    const bySeverity: Record<VulnerabilitySeverity, number> = {
      [VulnerabilitySeverity.CRITICAL]: 0,
      [VulnerabilitySeverity.HIGH]: 0,
      [VulnerabilitySeverity.MEDIUM]: 0,
      [VulnerabilitySeverity.LOW]: 0,
      [VulnerabilitySeverity.INFO]: 0
    };

    let totalCVSS = 0;
    let highestCVSS = 0;
    let patchableCount = 0;

    for (const finding of findings) {
      bySeverity[finding.severity]++;
      totalCVSS += finding.cvssScore;
      highestCVSS = Math.max(highestCVSS, finding.cvssScore);
      if (finding.patchAvailable) patchableCount++;
    }

    const avgCVSS = findings.length > 0 ? totalCVSS / findings.length : 0;

    const criticalFindings = bySeverity[VulnerabilitySeverity.CRITICAL];
    const highFindings = bySeverity[VulnerabilitySeverity.HIGH];
    const requiresAction = criticalFindings + highFindings;

    // Estimate remediation time
    // Critical: 8h, High: 4h, Medium: 2h, Low: 1h
    const estimatedRemediationTime =
      bySeverity[VulnerabilitySeverity.CRITICAL] * 8 +
      bySeverity[VulnerabilitySeverity.HIGH] * 4 +
      bySeverity[VulnerabilitySeverity.MEDIUM] * 2 +
      bySeverity[VulnerabilitySeverity.LOW] * 1;

    // Overall risk
    let overallRisk: string;
    if (criticalFindings > 0) {
      overallRisk = 'CRITICAL';
    } else if (highFindings > 5) {
      overallRisk = 'HIGH';
    } else if (highFindings > 0) {
      overallRisk = 'MEDIUM';
    } else {
      overallRisk = 'LOW';
    }

    // Key findings
    const keyFindings: string[] = [];
    if (criticalFindings > 0) {
      keyFindings.push(`${criticalFindings} critical vulnerabilities require immediate attention`);
    }
    if (highFindings > 0) {
      keyFindings.push(`${highFindings} high-severity vulnerabilities should be fixed within 7 days`);
    }
    if (patchableCount < findings.length) {
      keyFindings.push(`${findings.length - patchableCount} vulnerabilities have no patches available`);
    }
    if (avgCVSS > 7.0) {
      keyFindings.push(`Average CVSS score of ${avgCVSS.toFixed(1)} indicates high risk`);
    }

    return {
      totalVulnerabilities: findings.length,
      bySeverity,
      criticalFindings,
      highFindings,
      avgCVSS: Math.round(avgCVSS * 10) / 10,
      highestCVSS,
      patchableCount,
      requiresAction,
      estimatedRemediationTime,
      overallRisk,
      keyFindings
    };
  }

  /**
   * Generate remediation plan
   */
  private generateRemediationPlan(): RemediationAction[] {
    const actions: RemediationAction[] = [];
    let priority = 1;

    // Sort by severity and CVSS score
    const sortedFindings = [...this.config.findings].sort((a, b) => {
      if (a.severity !== b.severity) {
        return this.severityRank(b.severity) - this.severityRank(a.severity);
      }
      return b.cvssScore - a.cvssScore;
    });

    for (const finding of sortedFindings) {
      let action: RemediationAction['action'] = 'update';
      let effort: RemediationAction['effort'] = 'low';
      let estimatedHours = 1;
      let businessImpact: RemediationAction['businessImpact'] = 'none';

      if (finding.patchAvailable && finding.fixedIn) {
        action = 'update';
        effort = 'low';
        estimatedHours = finding.severity === VulnerabilitySeverity.CRITICAL ? 2 : 1;
      } else if (finding.patchAvailable) {
        action = 'patch';
        effort = 'medium';
        estimatedHours = finding.severity === VulnerabilitySeverity.CRITICAL ? 4 : 2;
      } else {
        action = 'replace';
        effort = 'high';
        estimatedHours = finding.severity === VulnerabilitySeverity.CRITICAL ? 8 : 4;
        businessImpact = 'medium';
      }

      // Generate command
      let command: string | undefined;
      if (action === 'update' && finding.fixedIn) {
        command = `npm update ${finding.package}@${finding.fixedIn}`;
      }

      // Calculate deadline
      let deadline: Date | undefined;
      if (finding.severity === VulnerabilitySeverity.CRITICAL) {
        deadline = new Date();
        deadline.setDate(deadline.getDate() + 1); // 1 day
      } else if (finding.severity === VulnerabilitySeverity.HIGH) {
        deadline = new Date();
        deadline.setDate(deadline.getDate() + 7); // 7 days
      } else if (finding.severity === VulnerabilitySeverity.MEDIUM) {
        deadline = new Date();
        deadline.setDate(deadline.getDate() + 30); // 30 days
      }

      actions.push({
        priority: priority++,
        vulnerability: finding.id,
        package: finding.package,
        action,
        command,
        effort,
        estimatedHours,
        businessImpact,
        deadline,
        status: 'pending'
      });
    }

    return actions;
  }

  /**
   * Generate risk assessment
   */
  private generateRiskAssessment(): RiskAssessment {
    const findings = this.config.findings;
    const summary = this.report.executiveSummary!;

    // Calculate exploitability (average EPSS)
    const epssScores = findings.filter(f => f.epssScore).map(f => f.epssScore!);
    const avgEPSS = epssScores.length > 0 ? epssScores.reduce((a, b) => a + b, 0) / epssScores.length : 0;
    const exploitability = Math.round(avgEPSS * 100);

    // Risk score (0-100)
    const riskScore = Math.min(
      100,
      summary.criticalFindings * 20 +
      summary.highFindings * 10 +
      (summary.avgCVSS / 10) * 30 +
      exploitability * 0.3
    );

    // Overall risk
    let overallRisk: RiskAssessment['overallRisk'];
    if (riskScore >= 80) {
      overallRisk = 'CRITICAL';
    } else if (riskScore >= 60) {
      overallRisk = 'HIGH';
    } else if (riskScore >= 40) {
      overallRisk = 'MEDIUM';
    } else {
      overallRisk = 'LOW';
    }

    // Likelihood
    let likelihood: RiskAssessment['likelihood'];
    if (exploitability >= 80) {
      likelihood = 'VERY_HIGH';
    } else if (exploitability >= 60) {
      likelihood = 'HIGH';
    } else if (exploitability >= 40) {
      likelihood = 'MEDIUM';
    } else if (exploitability >= 20) {
      likelihood = 'LOW';
    } else {
      likelihood = 'VERY_LOW';
    }

    // Impact
    let impact: RiskAssessment['impact'];
    if (summary.criticalFindings > 0) {
      impact = 'CATASTROPHIC';
    } else if (summary.highFindings > 5) {
      impact = 'SEVERE';
    } else if (summary.highFindings > 0) {
      impact = 'MODERATE';
    } else if (summary.totalVulnerabilities > 10) {
      impact = 'MINOR';
    } else {
      impact = 'NEGLIGIBLE';
    }

    // Mitigating factors
    const mitigatingFactors: string[] = [];
    if (summary.patchableCount / summary.totalVulnerabilities > 0.8) {
      mitigatingFactors.push('Most vulnerabilities have patches available');
    }
    if (avgEPSS < 0.3) {
      mitigatingFactors.push('Low exploit probability (EPSS < 0.3)');
    }

    // Aggravating factors
    const aggravatingFactors: string[] = [];
    if (summary.criticalFindings > 0) {
      aggravatingFactors.push('Critical vulnerabilities present');
    }
    if (avgEPSS > 0.7) {
      aggravatingFactors.push('High exploit probability (EPSS > 0.7)');
    }
    if (summary.patchableCount < summary.totalVulnerabilities * 0.5) {
      aggravatingFactors.push('Limited patch availability');
    }

    return {
      overallRisk,
      likelihood,
      impact,
      riskScore: Math.round(riskScore),
      exploitability,
      businessRisk: 'Potential service disruption, data breach, or reputational damage',
      technicalRisk: 'System compromise, unauthorized access, or data exfiltration',
      complianceRisk: 'Potential regulatory violations (GDPR, HIPAA, SOC2)',
      mitigatingFactors,
      aggravatingFactors
    };
  }

  /**
   * Generate compliance impact
   */
  private generateComplianceImpact(): ComplianceImpact {
    const summary = this.report.executiveSummary!;

    const frameworks = this.config.complianceFrameworks.map(name => {
      let affected = false;
      let requirements: string[] = [];
      let penalties = '';

      if (name === 'GDPR') {
        affected = summary.criticalFindings > 0 || summary.highFindings > 0;
        requirements = [
          'Article 32: Security of processing',
          'Article 33: Notification of breach (72 hours)',
          'Article 34: Communication to data subjects'
        ];
        penalties = 'Up to ‚Ç¨20M or 4% of global turnover';
      } else if (name === 'HIPAA') {
        affected = summary.criticalFindings > 0;
        requirements = [
          '¬ß164.308(a)(1): Security Management Process',
          '¬ß164.312(a)(1): Access Control',
          '¬ß164.312(b): Audit Controls'
        ];
        penalties = 'Up to $1.5M per violation category per year';
      } else if (name === 'SOC2') {
        affected = summary.highFindings > 0;
        requirements = [
          'CC6.1: Logical and physical access controls',
          'CC7.1: Vulnerability detection and remediation',
          'CC7.2: Security incident monitoring'
        ];
        penalties = 'Loss of certification, customer trust';
      } else if (name === 'PCI-DSS') {
        affected = summary.criticalFindings > 0 || summary.highFindings > 0;
        requirements = [
          'Requirement 6: Develop and maintain secure systems',
          'Requirement 11: Test security systems regularly'
        ];
        penalties = 'Fines up to $100K per month, card processing suspension';
      }

      return { name, affected, requirements, penalties };
    });

    const mustFix = frameworks.some(f => f.affected);
    const reportingRequired = summary.criticalFindings > 0;

    let deadline: Date | undefined;
    if (reportingRequired) {
      deadline = new Date();
      deadline.setHours(deadline.getHours() + 72); // 72 hours for GDPR
    }

    return {
      frameworks,
      mustFix,
      deadline,
      reportingRequired
    };
  }

  /**
   * Generate trends
   */
  private generateTrends(): VulnerabilityReport['trends'] {
    // Would compare with historical data
    // For now, return mock data
    return {
      newVulnerabilities: this.config.findings.length,
      fixedVulnerabilities: 0,
      trendDirection: 'stable'
    };
  }

  /**
   * Generate recommendations
   */
  private generateRecommendations(): string[] {
    const recommendations: string[] = [];
    const summary = this.report.executiveSummary!;

    if (summary.criticalFindings > 0) {
      recommendations.push(`üö® Immediate action: Fix ${summary.criticalFindings} critical vulnerabilities within 24 hours`);
    }

    if (summary.highFindings > 0) {
      recommendations.push(`‚ö†Ô∏è  High priority: Address ${summary.highFindings} high-severity vulnerabilities within 7 days`);
    }

    if (summary.patchableCount < summary.totalVulnerabilities) {
      recommendations.push(`üîÑ ${summary.totalVulnerabilities - summary.patchableCount} vulnerabilities require workarounds or package replacement`);
    }

    if (summary.avgCVSS > 7.0) {
      recommendations.push('üìà Implement automated dependency scanning in CI/CD pipeline');
    }

    recommendations.push('üìã Document all remediation actions in issue tracker');
    recommendations.push('üîç Schedule weekly vulnerability scans');
    recommendations.push('üìä Review security metrics in monthly board meetings');

    return recommendations;
  }

  /**
   * Get severity rank
   */
  private severityRank(severity: VulnerabilitySeverity): number {
    const ranks: Record<VulnerabilitySeverity, number> = {
      [VulnerabilitySeverity.CRITICAL]: 5,
      [VulnerabilitySeverity.HIGH]: 4,
      [VulnerabilitySeverity.MEDIUM]: 3,
      [VulnerabilitySeverity.LOW]: 2,
      [VulnerabilitySeverity.INFO]: 1
    };
    return ranks[severity];
  }

  /**
   * Export to JSON
   */
  exportToJSON(): string {
    return JSON.stringify(this.report, null, 2);
  }

  /**
   * Export to SARIF (Static Analysis Results Interchange Format)
   */
  exportToSARIF(): string {
    const sarif = {
      version: '2.1.0',
      $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
      runs: [
        {
          tool: {
            driver: {
              name: 'ODAVL Vulnerability Scanner',
              version: '1.0.0',
              informationUri: 'https://odavl.studio'
            }
          },
          results: this.config.findings.map(finding => ({
            ruleId: finding.id,
            level: this.severityToSARIFLevel(finding.severity),
            message: {
              text: finding.description
            },
            locations: [
              {
                physicalLocation: {
                  artifactLocation: {
                    uri: `package.json`
                  }
                }
              }
            ],
            properties: {
              cvssScore: finding.cvssScore,
              cvssVector: finding.cvssVector,
              package: finding.package,
              version: finding.version,
              fixedIn: finding.fixedIn
            }
          }))
        }
      ]
    };

    return JSON.stringify(sarif, null, 2);
  }

  /**
   * Export to CSV
   */
  exportToCSV(): string {
    const headers = [
      'CVE ID',
      'Severity',
      'CVSS',
      'Package',
      'Version',
      'Fixed In',
      'Patch Available',
      'Published Date',
      'Description'
    ];

    const rows = this.config.findings.map(f => [
      f.id,
      f.severity,
      f.cvssScore,
      f.package,
      f.version,
      f.fixedIn ?? 'N/A',
      f.patchAvailable ? 'Yes' : 'No',
      f.publishedDate.toISOString(),
      f.description.replace(/"/g, '""') // Escape quotes
    ]);

    return [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');
  }

  /**
   * Export to HTML
   */
  exportToHTML(): string {
    const report = this.report as VulnerabilityReport;
    
    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Vulnerability Report - ${report.metadata.projectName}</title>
  <style>
    body { font-family: system-ui; margin: 0; padding: 20px; background: #f5f5f5; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 40px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    .exec-summary { background: #ecf0f1; padding: 20px; border-radius: 5px; margin: 20px 0; }
    .metric { display: inline-block; margin: 10px 20px 10px 0; }
    .metric-value { font-size: 2em; font-weight: bold; }
    .metric-label { color: #666; font-size: 0.9em; }
    .critical { color: #e74c3c; }
    .high { color: #e67e22; }
    .medium { color: #f39c12; }
    .low { color: #3498db; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
    th { background: #34495e; color: white; }
    .recommendations { background: #d5f4e6; border-left: 4px solid #27ae60; padding: 15px; margin: 20px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üõ°Ô∏è Vulnerability Assessment Report</h1>
    <p><strong>Project:</strong> ${report.metadata.projectName} v${report.metadata.projectVersion}</p>
    <p><strong>Generated:</strong> ${report.metadata.generatedAt.toISOString()}</p>
    <p><strong>Report ID:</strong> ${report.metadata.reportId}</p>

    <div class="exec-summary">
      <h2>Executive Summary</h2>
      <div class="metric">
        <div class="metric-value">${report.executiveSummary.totalVulnerabilities}</div>
        <div class="metric-label">Total Vulnerabilities</div>
      </div>
      <div class="metric">
        <div class="metric-value critical">${report.executiveSummary.criticalFindings}</div>
        <div class="metric-label">Critical</div>
      </div>
      <div class="metric">
        <div class="metric-value high">${report.executiveSummary.highFindings}</div>
        <div class="metric-label">High</div>
      </div>
      <div class="metric">
        <div class="metric-value">${report.executiveSummary.avgCVSS}</div>
        <div class="metric-label">Avg CVSS</div>
      </div>
      <div class="metric">
        <div class="metric-value">${report.executiveSummary.estimatedRemediationTime}h</div>
        <div class="metric-label">Est. Remediation Time</div>
      </div>
    </div>

    <h2>Vulnerability Findings</h2>
    <table>
      <thead>
        <tr>
          <th>CVE ID</th>
          <th>Severity</th>
          <th>CVSS</th>
          <th>Package</th>
          <th>Fixed In</th>
        </tr>
      </thead>
      <tbody>
        ${report.findings.map(f => `
          <tr>
            <td>${f.id}</td>
            <td class="${f.severity.toLowerCase()}">${f.severity}</td>
            <td>${f.cvssScore}</td>
            <td>${f.package}@${f.version}</td>
            <td>${f.fixedIn ?? 'N/A'}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>

    <div class="recommendations">
      <h3>üìã Recommendations</h3>
      <ul>
        ${report.recommendations.map(r => `<li>${r}</li>`).join('')}
      </ul>
    </div>
  </div>
</body>
</html>
    `.trim();
  }

  /**
   * Convert severity to SARIF level
   */
  private severityToSARIFLevel(severity: VulnerabilitySeverity): string {
    switch (severity) {
      case VulnerabilitySeverity.CRITICAL:
      case VulnerabilitySeverity.HIGH:
        return 'error';
      case VulnerabilitySeverity.MEDIUM:
        return 'warning';
      case VulnerabilitySeverity.LOW:
      case VulnerabilitySeverity.INFO:
        return 'note';
      default:
        return 'note';
    }
  }

  /**
   * Save report to file
   */
  async save(outputPath: string, format: 'json' | 'sarif' | 'csv' | 'html' = 'json'): Promise<void> {
    let content: string;
    switch (format) {
      case 'json':
        content = this.exportToJSON();
        break;
      case 'sarif':
        content = this.exportToSARIF();
        break;
      case 'csv':
        content = this.exportToCSV();
        break;
      case 'html':
        content = this.exportToHTML();
        break;
    }
    await fs.writeFile(outputPath, content, 'utf-8');
    console.log(`‚úÖ Report saved to ${outputPath}`);
  }
}

/**
 * Convenience function to generate vulnerability report
 */
export async function generateVulnerabilityReport(
  config: VulnerabilityReporterConfig
): Promise<VulnerabilityReport> {
  const reporter = new VulnerabilityReporter(config);
  return reporter.generate();
}

/**
 * Quick report for CI/CD
 */
export async function quickVulnerabilityReport(
  findings: VulnerabilityFinding[],
  projectName: string
): Promise<VulnerabilityReport> {
  const reporter = new VulnerabilityReporter({
    findings,
    projectName,
    projectVersion: '1.0.0'
  });
  return reporter.generate();
}
