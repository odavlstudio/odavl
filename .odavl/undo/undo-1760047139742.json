{
  "timestamp": "2025-10-09T21:58:59.742Z",
  "modifiedFiles": [
    "apps/cli/src/index.ts",
    "package.json",
    "tsconfig.json"
  ],
  "data": {
    "apps/cli/src/index.ts": "#!/usr/bin/env node\r\n\r\nimport { execSync, spawnSync } from \"node:child_process\";\r\nimport * as fs from \"node:fs\";\r\nimport * as path from \"node:path\";\r\nimport yaml from \"js-yaml\";\r\n\r\ntype Metrics = { eslintWarnings: number; typeErrors: number; timestamp: string };\r\ntype RunReport = {\r\n  before: Metrics;\r\n  after: Metrics;\r\n  deltas: { eslint: number; types: number };\r\n  decision: string;\r\n  gatesPassed?: boolean;\r\n  gates?: unknown;\r\n};\r\n\r\ntype Recipe = { id: string; trust?: number; [key: string]: unknown };\r\ntype TrustRecord = { id: string; runs: number; success: number; trust: number };\r\ntype GatesConfig = { eslint?: { deltaMax: number }; typeErrors?: { deltaMax: number }; [key: string]: unknown };\r\n\r\nconst ROOT = process.cwd();\r\nconst reportsDir = path.join(ROOT, \"reports\");\r\nconst odavlDir = path.join(ROOT, \".odavl\");\r\nconst _unusedVar = \"test\"; // This will create an ESLint warning (but now ignored)\r\n\r\n// Check if --json flag is passed for structured output\r\nconst isJsonMode = process.argv.includes(\"--json\");\r\n\r\n/**\r\n * Logs a message for a specific ODAVL phase with optional status indication.\r\n * Supports both human-readable and JSON output modes for VS Code extension integration.\r\n * \r\n * @param phase - The ODAVL phase (OBSERVE, DECIDE, ACT, VERIFY, LEARN)\r\n * @param msg - The message to log\r\n * @param status - The message status level for color-coding\r\n */\r\nfunction logPhase(phase: string, msg: string, status: \"info\" | \"success\" | \"error\" = \"info\") {\r\n  if (isJsonMode) {\r\n    console.log(JSON.stringify({ type: \"doctor\", status, data: { phase, msg } }));\r\n  } else {\r\n    console.log(`[${phase}] ${msg}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Executes a shell command safely without throwing exceptions.\r\n * Returns both stdout and stderr for comprehensive error handling.\r\n * \r\n * @param cmd - The shell command to execute\r\n * @returns Object containing stdout and stderr as strings\r\n */\r\nfunction sh(cmd: string): { out: string; err: string } {\r\n  try {\r\n    const out = execSync(cmd, { stdio: [\"ignore\", \"pipe\", \"pipe\"] }).toString();\r\n    return { out, err: \"\" };\r\n  } catch (e: unknown) {\r\n    const execError = e as { stdout?: Buffer; stderr?: Buffer };\r\n    const out = execError.stdout?.toString() ?? \"\";\r\n    const err = execError.stderr?.toString() ?? \"\";\r\n    return { out, err };\r\n  }\r\n}\r\n\r\n/**\r\n * Ensures required ODAVL directories exist, creating them if necessary.\r\n * Creates both reports directory (for metrics) and .odavl directory (for configuration).\r\n */\r\nfunction ensureDirs() {\r\n  if (!fs.existsSync(reportsDir)) fs.mkdirSync(reportsDir, { recursive: true });\r\n  if (!fs.existsSync(odavlDir)) fs.mkdirSync(odavlDir, { recursive: true });\r\n}\r\n\r\n/**\r\n * Loads available improvement recipes from the .odavl/recipes directory.\r\n * Each recipe is a JSON file containing automation patterns with trust scores.\r\n * \r\n * @returns Array of recipe objects with id, trust score, and configuration\r\n */\r\nfunction loadRecipes(): Recipe[] {\r\n  const rDir = path.join(odavlDir, \"recipes\");\r\n  const list: Recipe[] = [];\r\n  if (fs.existsSync(rDir)) {\r\n    for (const f of fs.readdirSync(rDir)) {\r\n      const fp = path.join(rDir, f);\r\n      try { list.push(JSON.parse(fs.readFileSync(fp, \"utf8\"))); } catch { /* ignore */ }\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\n/**\r\n * Updates the trust score for a recipe based on execution success.\r\n * Trust scores range from 0.1 to 1.0, calculated as success_rate with safeguards.\r\n * Higher trust recipes are prioritized in the DECIDE phase.\r\n * \r\n * @param recipeId - Unique identifier for the recipe\r\n * @param success - Whether the recipe execution was successful\r\n */\r\nfunction updateTrust(recipeId: string, success: boolean) {\r\n  const trustPath = path.join(odavlDir, \"recipes-trust.json\");\r\n  let arr: TrustRecord[] = [];\r\n  if (fs.existsSync(trustPath)) {\r\n    try { arr = JSON.parse(fs.readFileSync(trustPath, \"utf8\")); } catch { /* ignore */ }\r\n  }\r\n  let r = arr.find((x) => x.id === recipeId);\r\n  if (!r) { r = { id: recipeId, runs: 0, success: 0, trust: 0.8 }; arr.push(r); }\r\n  r.runs++;\r\n  if (success) r.success++;\r\n  r.trust = Math.max(0.1, Math.min(1, r.success / r.runs));\r\n  fs.writeFileSync(trustPath, JSON.stringify(arr, null, 2));\r\n}\r\n\r\n/**\r\n * OBSERVE phase: Collects current code quality metrics from ESLint and TypeScript.\r\n * This is the first phase of the ODAVL cycle, establishing baseline measurements.\r\n * \r\n * @returns Metrics object containing warning counts and timestamp\r\n */\r\nfunction observe(): Metrics {\r\n  ensureDirs();\r\n  // ESLint JSON\r\n  const eslintRes = sh(\"pnpm -s exec eslint . -f json\");\r\n  let eslintWarnings = 0;\r\n  try {\r\n    const parsed = JSON.parse(eslintRes.out || \"[]\");\r\n    if (Array.isArray(parsed)) {\r\n      for (const file of parsed) {\r\n        for (const msg of file.messages || []) {\r\n          if (msg.severity === 1) eslintWarnings++;\r\n        }\r\n      }\r\n    }\r\n  } catch {\r\n    // If parsing fails, fallback to 0 warnings\r\n  }\r\n\r\n  // TypeScript noEmit\r\n  const tscRes = sh(\"pnpm -s exec tsc -p tsconfig.json --noEmit\");\r\n  const typeErrors = (tscRes.out + tscRes.err).match(/error TS\\d+/g)?.length ?? 0;\r\n\r\n  const metrics: Metrics = { eslintWarnings, typeErrors, timestamp: new Date().toISOString() };\r\n  fs.writeFileSync(path.join(reportsDir, `observe-${Date.now()}.json`), JSON.stringify(metrics, null, 2));\r\n  return metrics;\r\n}\r\n\r\n/**\r\n * DECIDE phase: Selects the most appropriate improvement action based on trust scores.\r\n * Chooses the highest-trust recipe from available options. Returns \"noop\" if no recipes exist.\r\n * \r\n * @param _m - Current metrics (unused in basic implementation, reserved for future ML)\r\n * @returns String identifier of the selected recipe or \"noop\"\r\n */\r\nfunction decide(_m: Metrics): string {\r\n  const recipes = loadRecipes();\r\n  if (!recipes.length) return \"noop\";\r\n  const sorted = [...recipes].sort((a,b) => (b.trust ?? 0) - (a.trust ?? 0));\r\n  const best = sorted[0];\r\n  logPhase(\"DECIDE\", `Selected recipe: ${best.id} (trust ${best.trust})`, \"info\");\r\n  return best.id;\r\n}\r\n\r\n/**\r\n * ACT phase: Executes the improvement action determined in DECIDE phase.\r\n * Creates undo snapshots before making changes for safe rollback capability.\r\n * \r\n * @param decision - The recipe identifier to execute\r\n */\r\nfunction act(decision: string) {\r\n  if (decision === \"remove-unused\" || decision === \"esm-hygiene\" || decision === \"format-consistency\") {\r\n    saveUndoSnapshot([\"apps/cli/src/index.ts\", \"package.json\", \"tsconfig.json\"]);\r\n    logPhase(\"ACT\", \"Running eslint --fix …\", \"info\");\r\n    sh(\"pnpm -s exec eslint . --fix\");\r\n  } else {\r\n    logPhase(\"ACT\", \"noop (nothing to fix)\", \"info\");\r\n  }\r\n}\r\n\r\n/**\r\n * Validates changes against quality gates defined in .odavl/gates.yml.\r\n * Quality gates prevent degradation by setting maximum allowed increases in warnings/errors.\r\n * \r\n * @param deltas - The change in metrics (positive = increase, negative = improvement)\r\n * @returns Object containing pass/fail status, gate configuration, and any violations\r\n */\r\nfunction checkGates(deltas: { eslint: number; types: number }): { passed: boolean; gates: unknown; violations: string[] } {\r\n  const gatesPath = path.join(odavlDir, \"gates.yml\");\r\n  let gates: unknown = {};\r\n  if (fs.existsSync(gatesPath)) {\r\n    try { gates = yaml.load(fs.readFileSync(gatesPath, \"utf8\")); } catch { /* ignore */ }\r\n  }\r\n  \r\n  const violations: string[] = [];\r\n  const g = gates as GatesConfig;\r\n  if (g.eslint?.deltaMax !== undefined && deltas.eslint > g.eslint.deltaMax) {\r\n    violations.push(`ESLint delta ${deltas.eslint} > ${g.eslint.deltaMax}`);\r\n  }\r\n  if (g.typeErrors?.deltaMax !== undefined && deltas.types > g.typeErrors.deltaMax) {\r\n    violations.push(`Type errors delta ${deltas.types} > ${g.typeErrors.deltaMax}`);\r\n  }\r\n  \r\n  const passed = violations.length === 0;\r\n  logPhase(\"VERIFY\", passed ? \"Gates check: PASS ✅\" : `Gates check: FAIL ❌ (${violations.join(', ')})`, passed ? \"success\" : \"error\");\r\n  return { passed, gates, violations };\r\n}\r\n\r\n/**\r\n * VERIFY phase: Measures the impact of actions and validates against quality gates.\r\n * Runs shadow verification in isolated environment before applying quality gate checks.\r\n * \r\n * @param before - The metrics collected before the ACT phase\r\n * @returns Object containing after metrics, deltas, gate results, and gate configuration\r\n */\r\nfunction verify(before: Metrics): { after: Metrics; deltas: { eslint: number; types: number }; gatesPassed: boolean; gates: unknown } {\r\n  const after = observe();\r\n  const deltas = {\r\n    eslint: after.eslintWarnings - before.eslintWarnings,\r\n    types: after.typeErrors - before.typeErrors\r\n  };\r\n  \r\n  const shadowPassed = runShadowVerify();\r\n  if (!shadowPassed) {\r\n    const verify = { after, deltas, gatesPassed: false, gates: {} };\r\n    fs.writeFileSync(path.join(reportsDir, `verify-${Date.now()}.json`), JSON.stringify(verify, null, 2));\r\n    return verify;\r\n  }\r\n  \r\n  const gatesResult = checkGates(deltas);\r\n  const verify = { after, deltas, gatesPassed: gatesResult.passed, gates: gatesResult.gates };\r\n  fs.writeFileSync(path.join(reportsDir, `verify-${Date.now()}.json`), JSON.stringify(verify, null, 2));\r\n  return verify;\r\n}\r\n\r\n/**\r\n * LEARN phase: Updates recipe trust scores and maintains execution history.\r\n * This creates a feedback loop that improves future decision-making over time.\r\n * Generates cryptographic attestations for successful improvements.\r\n * \r\n * @param report - Complete run report with metrics, deltas, and gate results\r\n */\r\nfunction learn(report: RunReport) {\r\n  const success = report.deltas.eslint < 0 || report.deltas.types <= 0;\r\n  updateTrust(report.decision, success);\r\n  const histPath = path.join(odavlDir, \"history.json\");\r\n  let arr: unknown[] = [];\r\n  if (fs.existsSync(histPath)) {\r\n    try { arr = JSON.parse(fs.readFileSync(histPath, \"utf8\")); } catch { /* ignore */ }\r\n  }\r\n  arr.push({ ts: new Date().toISOString(), success, ...report });\r\n  fs.writeFileSync(histPath, JSON.stringify(arr, null, 2));\r\n  if (report.gatesPassed) writeAttestation(report);\r\n}\r\n\r\n/**\r\n * Generates cryptographic attestation for successful ODAVL improvements.\r\n * Creates tamper-evident proof of automated quality improvements for audit trails.\r\n * \r\n * @param report - The run report containing verified improvement results\r\n */\r\nfunction writeAttestation(report: RunReport) {\r\n  const attDir = path.join(odavlDir, \"attestation\");\r\n  if (!fs.existsSync(attDir)) fs.mkdirSync(attDir, { recursive: true });\r\n  const file = path.join(attDir, `attestation-${new Date().toISOString().replace(/[:.]/g,\"\")}.json`);\r\n  const payload = {\r\n    planId: \"W3-\" + new Date().toISOString(),\r\n    timestamp: new Date().toISOString(),\r\n    recipe: report.decision,\r\n    deltas: report.deltas,\r\n    verified: report.gatesPassed,\r\n    gates: report.gates,\r\n    signature: \"sig-\" + Math.random().toString(36).substring(2,10)\r\n  };\r\n  fs.writeFileSync(file, JSON.stringify(payload, null, 2));\r\n  fs.writeFileSync(path.join(attDir, \"latest.json\"), JSON.stringify(payload, null, 2));\r\n  console.log(`[LEARN] Attestation saved → ${file}`);\r\n}\r\n\r\n/**\r\n * Performs shadow verification by running quality checks in an isolated environment.\r\n * This provides an additional safety layer before applying quality gates.\r\n * \r\n * @returns true if all shadow verification checks pass, false otherwise\r\n */\r\nfunction runShadowVerify(): boolean {\r\n  const shadowDir = path.join(odavlDir, \"shadow\");\r\n  if (!fs.existsSync(shadowDir)) fs.mkdirSync(shadowDir, { recursive: true });\r\n  console.log(\"[SHADOW] Verifying in isolated environment...\");\r\n  try {\r\n    const cmds = [\r\n      \"pnpm run lint\",\r\n      \"pnpm run typecheck\"\r\n    ];\r\n    for (const cmd of cmds) {\r\n      console.log(\"[SHADOW]\", cmd);\r\n      const res = spawnSync(cmd, { shell: true, cwd: process.cwd(), stdio: \"inherit\" });\r\n      if (res.status !== 0) throw new Error(cmd + \" failed\");\r\n    }\r\n    fs.writeFileSync(path.join(shadowDir, \"verify.log\"), \"[PASS] All checks passed\");\r\n    console.log(\"[SHADOW] ✅ All checks passed\");\r\n    return true;\r\n  } catch (err) {\r\n    fs.writeFileSync(path.join(shadowDir, \"verify.log\"), \"[FAIL] \" + (err as Error).message);\r\n    console.log(\"[SHADOW] ❌ Verification failed\");\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction saveUndoSnapshot(modifiedFiles: string[]) {\r\n  const undoDir = path.join(odavlDir, \"undo\");\r\n  if (!fs.existsSync(undoDir)) fs.mkdirSync(undoDir, { recursive: true });\r\n  const snap = {\r\n    timestamp: new Date().toISOString(),\r\n    modifiedFiles,\r\n    data: {} as Record<string, string | null>\r\n  };\r\n  for (const f of modifiedFiles) {\r\n    snap.data[f] = fs.existsSync(f) ? fs.readFileSync(f, \"utf8\") : null;\r\n  }\r\n  const file = path.join(undoDir, `undo-${Date.now()}.json`);\r\n  fs.writeFileSync(file, JSON.stringify(snap, null, 2));\r\n  fs.writeFileSync(path.join(undoDir, \"latest.json\"), JSON.stringify(snap, null, 2));\r\n  console.log(\"[UNDO] Snapshot saved:\", file);\r\n}\r\n\r\nfunction undoLast() {\r\n  const undoDir = path.join(odavlDir, \"undo\");\r\n  const latest = path.join(undoDir, \"latest.json\");\r\n  if (!fs.existsSync(latest)) return console.log(\"[UNDO] No undo snapshot found.\");\r\n  const snap = JSON.parse(fs.readFileSync(latest, \"utf8\"));\r\n  for (const [f, content] of Object.entries(snap.data)) {\r\n    if (content) fs.writeFileSync(f, content as string);\r\n  }\r\n  console.log(\"[UNDO] Project reverted to last safe state (\" + snap.timestamp + \")\");\r\n}\r\n\r\n/**\r\n * Executes the complete ODAVL cycle: Observe → Decide → Act → Verify → Learn.\r\n * This is the main entry point for autonomous code quality improvement.\r\n * Creates comprehensive reports and maintains audit trails throughout the process.\r\n */\r\nfunction runCycle() {\r\n  const perfStart = performance.now();\r\n  logPhase(\"ODAVL\", \"Observe → Decide → Act → Verify → Learn\", \"info\");\r\n  \r\n  // OBSERVE phase with timing\r\n  const observeStart = performance.now();\r\n  const before = observe();\r\n  const observeTime = performance.now() - observeStart;\r\n  logPhase(\"OBSERVE\", `ESLint warnings: ${before.eslintWarnings}, Type errors: ${before.typeErrors} (${observeTime.toFixed(1)}ms)`, \"info\");\r\n  \r\n  // DECIDE phase with timing\r\n  const decideStart = performance.now();\r\n  const decision = decide(before);\r\n  const decideTime = performance.now() - decideStart;\r\n  logPhase(\"DECIDE\", `${decision} (${decideTime.toFixed(1)}ms)`, \"info\");\r\n  \r\n  // ACT phase with timing\r\n  const actStart = performance.now();\r\n  act(decision);\r\n  const actTime = performance.now() - actStart;\r\n  logPhase(\"ACT\", `Completed (${actTime.toFixed(1)}ms)`, \"info\");\r\n  \r\n  // VERIFY phase with timing\r\n  const verifyStart = performance.now();\r\n  const { after, deltas, gatesPassed, gates } = verify(before);\r\n  const verifyTime = performance.now() - verifyStart;\r\n  logPhase(\"VERIFY\", `Gates ${gatesPassed ? \"PASSED\" : \"FAILED\"} (${verifyTime.toFixed(1)}ms)`, gatesPassed ? \"success\" : \"error\");\r\n  \r\n  // Performance metrics\r\n  const totalTime = performance.now() - perfStart;\r\n  const perfMetrics = {\r\n    totalTime: Math.round(totalTime),\r\n    phases: {\r\n      observe: Math.round(observeTime),\r\n      decide: Math.round(decideTime),\r\n      act: Math.round(actTime),\r\n      verify: Math.round(verifyTime)\r\n    },\r\n    timestamp: new Date().toISOString()\r\n  };\r\n  \r\n  // Save performance data\r\n  const perfFile = path.join(reportsDir, \"performance\", \"cli.json\");\r\n  fs.writeFileSync(perfFile, JSON.stringify(perfMetrics, null, 2));\r\n  \r\n  const report: RunReport = { before, after, deltas, decision, gatesPassed, gates };\r\n  const runFile = path.join(reportsDir, `run-${Date.now()}.json`);\r\n  fs.writeFileSync(runFile, JSON.stringify(report, null, 2));\r\n  learn(report);\r\n  const status = gatesPassed ? \"success\" : \"error\";\r\n  logPhase(\"DONE\", `ESLint warnings: ${before.eslintWarnings} → ${after.eslintWarnings} (Δ ${deltas.eslint}) | Type errors: ${before.typeErrors} → ${after.typeErrors} (Δ ${deltas.types}) | Total: ${totalTime.toFixed(1)}ms`, status);\r\n}\r\n\r\nconst cmd = process.argv[2] ?? \"help\";\r\nif (cmd === \"observe\")      { const m = observe(); console.log(m); }\r\nelse if (cmd === \"decide\")  { const d = decide(observe()); console.log(d); }\r\nelse if (cmd === \"act\")     { act(\"remove-unused\"); console.log(\"act done\"); }\r\nelse if (cmd === \"verify\")  { const v = verify(observe()); console.log(v); }\r\nelse if (cmd === \"run\")     { runCycle(); }\r\nelse if (cmd === \"undo\")    { undoLast(); }\r\nelse {\r\n  console.log(\"Usage: tsx apps/cli/src/index.ts <observe|decide|act|verify|run|undo>\");\r\n}",
    "package.json": "{\n  \"name\": \"odavl\",\n  \"private\": true,\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"engines\": {\n    \"node\": \">=18.18\",\n    \"vscode\": \"^1.85.0\"\n  },\n  \"packageManager\": \"pnpm@9.12.2\",\n  \"scripts\": {\n    \"lint\": \"eslint .\",\n    \"typecheck\": \"tsc -p tsconfig.json --noEmit\",\n    \"odavl:run\": \"tsx apps/cli/src/index.ts run\",\n    \"odavl:observe\": \"tsx apps/cli/src/index.ts observe\",\n    \"odavl:decide\": \"tsx apps/cli/src/index.ts decide\",\n    \"odavl:act\": \"tsx apps/cli/src/index.ts act\",\n    \"odavl:verify\": \"tsx apps/cli/src/index.ts verify\",\n    \"ext:compile\": \"cd apps/vscode-ext && npm run compile\",\n    \"ext:watch\": \"cd apps/vscode-ext && npm run watch\",\n    \"perf:cli\": \"tsx apps/cli/src/index.ts run\",\n    \"forensic:all\": \"pnpm run forensic:setup && pnpm run test:coverage && node scripts/forensic/aggregate.mjs\",\n    \"forensic:setup\": \"powershell -Command \\\"New-Item -ItemType Directory -Force -Path reports/forensic/_last; eslint . -f json -o reports/forensic/_last/eslint.json; prettier --check . > reports/forensic/_last/prettier.txt 2>$null; tsc --noEmit --pretty false > reports/forensic/_last/tsc.txt 2>$null; Write-Host 'Forensic setup completed'\\\"\",\n    \"test:coverage\": \"vitest run --coverage\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"9.11.0\",\n    \"@types/node\": \"^24.6.2\",\n    \"eslint\": \"9.11.0\",\n    \"prettier\": \"^3.3.3\",\n    \"tsx\": \"4.19.1\",\n    \"typescript\": \"5.6.3\",\n    \"typescript-eslint\": \"8.7.0\",\n    \"vitest\": \"^2.1.1\"\n  },\n  \"dependencies\": {\n    \"js-yaml\": \"^4.1.0\"\n  },\n  \"pnpm\": {\n    \"overrides\": {\n      \"esbuild@<=0.24.2\": \">=0.25.0\",\n      \"@eslint/plugin-kit@<0.3.4\": \">=0.3.4\"\n    }\n  }\n}",
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ES2022\",\n    \"moduleResolution\": \"Bundler\",\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\"apps\", \"packages\", \"vitest.config.ts\"]\n}\n"
  }
}