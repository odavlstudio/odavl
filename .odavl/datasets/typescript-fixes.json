[
  {
    "id": "freeCodeCamp/freeCodeCamp-c5676e3145c62bbb000d47984fff95de019f8f1c-api/src/plugins/auth0.test.ts",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import {\n  describe,\n  test,\n  expect,\n  beforeAll,\n  afterAll,\n  beforeEach,\n  afterEach,\n  vi,\n  MockInstance\n} from 'vitest';\nimport Fastify, { FastifyInstance } from 'fastify';\n\nimport { createUserInput } from '../utils/create-user.js';\nimport { AUTH0_DOMAIN, HOME_LOCATION } from '../utils/env.js';\nimport prismaPlugin from '../db/prisma.js';\nimport cookies, { sign, unsign } from './cookies.js';\nimport { auth0Client } from './auth0.js';\nimport redirectWithMessage, { formatMessage } from './redirect-with-message.js';\nimport auth from './auth.js';\nimport bouncer from './bouncer.js';\nimport { newUser } from './__fixtures__/user.js';\n\nconst COOKIE_DOMAIN = 'test.com';\n\nvi.mock('../utils/env', async importOriginal => ({\n  ...(await importOriginal<typeof import('../utils/env.js')>()),\n  COOKIE_DOMAIN: 'test.com'\n}));\n\ndescribe('auth0 plugin', () => {\n  let fastify: FastifyInstance;\n\n  beforeAll(async () => {\n    fastify = Fastify();\n\n    await fastify.register(cookies);\n    await fastify.register(redirectWithMessage);\n    await fastify.register(auth);\n    await fastify.register(bouncer);\n    await fastify.register(auth0Client);\n    await fastify.register(prismaPlugin);\n  });\n\n  describe('GET /signin/google', () => {\n    test('should redirect directly to Google via Auth0 with connection param', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin/google'\n      });\n      const redirectUrl = new URL(res.headers.location!);\n      expect(redirectUrl.host).toMatch(AUTH0_DOMAIN);\n      expect(redirectUrl.pathname).toBe('/authorize');\n      expect(redirectUrl.searchParams.get('connection')).toBe('google-oauth2');\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('sets a login-returnto cookie', async () => {\n      const returnTo = 'http://localhost:3000/learn';\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin/google',\n        headers: { referer: returnTo }\n      });\n      const cookie = res.cookies.find(c => c.name === 'login-returnto');\n      expect(unsign(cookie!.value).value).toBe(returnTo);\n      expect(cookie).toMatchObject({\n        domain: COOKIE_DOMAIN,\n        httpOnly: true,\n        secure: true,\n        sameSite: 'Lax'\n      });\n    });\n  });\n\n  afterAll(async () => {\n    await fastify.prisma.$runCommandRaw({ dropDatabase: 1 });\n    await fastify.close();\n  });\n\n  describe('GET /signin', () => {\n    test('should redirect to the auth0 login page', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin'\n      });\n\n      const redirectUrl = new URL(res.headers.location!);\n      expect(redirectUrl.host).toMatch(AUTH0_DOMAIN);\n      expect(redirectUrl.pathname).toBe('/authorize');\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('sets a login-returnto cookie', async () => {\n      const returnTo = 'http://localhost:3000/learn';\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin',\n        headers: {\n          referer: returnTo\n        }\n      });\n\n      const cookie = res.cookies.find(c => c.name === 'login-returnto');\n      expect(unsign(cookie!.value).value).toBe(returnTo);\n      expect(cookie).toMatchObject({\n        domain: COOKIE_DOMAIN,\n        httpOnly: true,\n        secure: true,\n        sameSite: 'Lax'\n      });\n    });\n  });\n\n  describe('GET /auth/auth0/callback', () => {\n    const email = 'new@user.com';\n    let getAccessTokenFromAuthorizationCodeFlowSpy: MockInstance;\n    let userinfoSpy: MockInstance;\n\n    const mockAuthSuccess = () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockResolvedValueOnce({\n        token: 'any token'\n      });\n      userinfoSpy.mockResolvedValueOnce(Promise.resolve({ email }));\n    };\n\n    beforeEach(() => {\n      getAccessTokenFromAuthorizationCodeFlowSpy = vi.spyOn(\n        fastify.auth0OAuth,\n        'getAccessTokenFromAuthorizationCodeFlow'\n      );\n      userinfoSpy = vi.spyOn(fastify.auth0OAuth, 'userinfo');\n      // @ts-expect-error - Only mocks part of the Sentry object.\n      fastify.Sentry = { captureException: () => '' };\n    });\n\n    afterEach(async () => {\n      vi.restoreAllMocks();\n      await fastify.prisma.user.deleteMany({ where: { email } });\n    });\n\n    test('should redirect to the client if authentication fails', async () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockRejectedValueOnce(\n        'any error'\n      );\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback'\n      });\n\n      expect(res.headers.location).toMatch(\n        `${HOME_LOCATION}/?${formatMessage({ type: 'danger', content: 'flash.generic-error' })}`\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should redirect to the client if the state is invalid', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(res.headers.location).toMatch(\n        `${HOME_LOCATION}/?${formatMessage({ type: 'danger', content: 'flash.generic-error' })}`\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should log an error if the state is invalid', async () => {\n      vi.spyOn(fastify.log, 'error');\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(fastify.log.error).toHaveBeenCalledWith(\n        'Auth failed: invalid state'\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should log expected Auth0 errors', async () => {\n      vi.spyOn(fastify.log, 'error');\n      const auth0Error = Error('Response Error: 403 Forbidden');\n      // @ts-expect-error - mocking a hapi/boom error\n      auth0Error.data = {\n        payload: {\n          error: 'invalid_grant'\n        }\n      };\n\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockRejectedValueOnce(\n        auth0Error\n      );\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(fastify.log.error).toHaveBeenCalledWith(\n        auth0Error,\n        'Auth failed: invalid_grant'\n      );\n\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should not create a user if the state is invalid', async () => {\n      await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(await fastify.prisma.user.count()).toBe(0);\n    });\n\n    test('should block requests with \"access_denied\" error', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?error=access_denied&error_description=Access denied from your location'\n      });\n\n      expect(res.statusCode).toBe(302);\n      expect(res.headers.location).toMatch(`${HOME_LOCATION}/blocked`);\n\n      const resWithoutDescription = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?error=access_denied'\n      });\n\n      expect(resWithoutDescription.statusCode).toBe(302);\n      expect(resWithoutDescription.headers.location).toMatch(\n        `${HOME_LOCATION}/learn?messages=`\n      );\n    });\n\n    test('creates a user if the state is valid', async () => {\n      mockAuthSuccess();\n      await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      expect(await fastify.prisma.user.count()).toBe(1);\n    });\n\n    test('handles userinfo errors', async () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockResolvedValueOnce({\n        token: 'any token'\n      });\n      userinfoSpy.mockResolvedValueOnce(Promise.reject(Error('any error')));\n      const returnTo = 'https://www.freecodecamp.org/espanol/learn';\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': sign(returnTo) }\n      });\n\n      expect(res.headers.location).toMatch(\n        returnTo +\n          `?${formatMessage({ type: 'danger', content: 'flash.generic-error' })}`\n      );\n      expect(res.statusCode).toBe(302);\n      expect(await fastify.prisma.user.count()).toBe(0);\n    });\n\n    test('handles invalid userinfo responses', async () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockResolvedValueOnce({\n        token: 'any token'\n      });\n      userinfoSpy.mockResolvedValueOnce(Promise.resolve({}));\n      const returnTo = 'https://www.freecodecamp.org/espanol/learn';\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': sign(returnTo) }\n      });\n\n      expect(res.headers.location).toMatch(\n        returnTo +\n          `?${formatMessage({ type: 'danger', content: 'flash.no-email-in-userinfo' })}`\n      );\n      expect(res.statusCode).toBe(302);\n      expect(await fastify.prisma.user.count()).toBe(0);\n    });\n\n    test('redirects with the signin-success message on success', async () => {\n      mockAuthSuccess();\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      expect(res.headers.location).toMatch(\n        `?${formatMessage({ type: 'success', content: 'flash.signin-success' })}`\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should set the jwt_access_token cookie', async () => {\n      mockAuthSuccess();\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      expect(res.headers['set-cookie']).toEqual(\n        expect.stringMatching(/jwt_access_token=/)\n      );\n    });\n\n    test('should use the login-returnto cookie if present and valid', async () => {\n      mockAuthSuccess();\n      await fastify.prisma.user.create({\n        data: { ...createUserInput(email), acceptedPrivacyTerms: true }\n      });\n      const returnTo = 'https://www.freecodecamp.org/espanol/learn';\n      // /signin sets the cookie\n      const req = await fastify.inject({\n        method: 'GET',\n        url: '/signin',\n        headers: {\n          referer: returnTo\n        }\n      });\n      const returnToCookie = req.cookies.find(c => c.name === 'login-returnto');\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': returnToCookie!.value }\n      });\n\n      expect(res.headers.location).toBe(\n        `${returnTo}?${formatMessage({ type: 'success', content: 'flash.signin-success' })}`\n      );\n    });\n\n    test('should redirect home if the login-returnto cookie is invalid', async () => {\n      mockAuthSuccess();\n      const returnTo = 'https://www.evilcodecamp.org/espanol/learn';\n      // /signin sets the cookie\n      const req = await fastify.inject({\n        method: 'GET',\n        url: '/signin',\n        headers: {\n          referer: returnTo\n        }\n      });\n      const returnToCookie = req.cookies.find(c => c.name === 'login-returnto');\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': returnToCookie!.value }\n      });\n\n      expect(res.headers.location).toMatch(HOME_LOCATION);\n    });\n\n    test('should populate the user with the correct data', async () => {\n      mockAuthSuccess();\n\n      await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      const user = await fastify.prisma.user.findFirstOrThrow({\n        where: { email }\n      });\n\n      expect(user).toEqual(newUser(email));\n      expect(user.username).toBe(user.usernameDisplay);\n    });\n  });\n});\n",
    "afterCode": "import {\n  describe,\n  test,\n  expect,\n  beforeAll,\n  afterAll,\n  beforeEach,\n  afterEach,\n  vi,\n  MockInstance\n} from 'vitest';\nimport Fastify, { FastifyInstance } from 'fastify';\n\nimport { createUserInput } from '../utils/create-user.js';\nimport { AUTH0_DOMAIN, HOME_LOCATION } from '../utils/env.js';\nimport prismaPlugin from '../db/prisma.js';\nimport cookies, { sign, unsign } from './cookies.js';\nimport { auth0Client } from './auth0.js';\nimport redirectWithMessage, { formatMessage } from './redirect-with-message.js';\nimport auth from './auth.js';\nimport bouncer from './bouncer.js';\nimport { newUser } from './__fixtures__/user.js';\n\nconst COOKIE_DOMAIN = 'test.com';\n\nvi.mock('../utils/env', async importOriginal => ({\n  ...(await importOriginal<typeof import('../utils/env.js')>()),\n  COOKIE_DOMAIN: 'test.com'\n}));\n\ndescribe('auth0 plugin', () => {\n  let fastify: FastifyInstance;\n\n  beforeAll(async () => {\n    fastify = Fastify();\n\n    await fastify.register(cookies);\n    await fastify.register(redirectWithMessage);\n    await fastify.register(auth);\n    await fastify.register(bouncer);\n    await fastify.register(auth0Client);\n    await fastify.register(prismaPlugin);\n  });\n\n  describe('GET /signin/google', () => {\n    test('should redirect directly to Google via Auth0 with connection param', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin/google'\n      });\n      const redirectUrl = new URL(res.headers.location!);\n      expect(redirectUrl.host).toMatch(AUTH0_DOMAIN);\n      expect(redirectUrl.pathname).toBe('/authorize');\n      expect(redirectUrl.searchParams.get('connection')).toBe('google-oauth2');\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('sets a login-returnto cookie', async () => {\n      const returnTo = 'http://localhost:3000/learn';\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin/google',\n        headers: { referer: returnTo }\n      });\n      const cookie = res.cookies.find(c => c.name === 'login-returnto');\n      expect(unsign(cookie!.value).value).toBe(returnTo);\n      expect(cookie).toMatchObject({\n        domain: COOKIE_DOMAIN,\n        httpOnly: true,\n        secure: true,\n        sameSite: 'Lax'\n      });\n    });\n  });\n\n  afterAll(async () => {\n    await fastify.prisma.$runCommandRaw({ dropDatabase: 1 });\n    await fastify.close();\n  });\n\n  describe('GET /signin', () => {\n    test('should redirect to the auth0 login page', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin'\n      });\n\n      const redirectUrl = new URL(res.headers.location!);\n      expect(redirectUrl.host).toMatch(AUTH0_DOMAIN);\n      expect(redirectUrl.pathname).toBe('/authorize');\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('sets a login-returnto cookie', async () => {\n      const returnTo = 'http://localhost:3000/learn';\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/signin',\n        headers: {\n          referer: returnTo\n        }\n      });\n\n      const cookie = res.cookies.find(c => c.name === 'login-returnto');\n      expect(unsign(cookie!.value).value).toBe(returnTo);\n      expect(cookie).toMatchObject({\n        domain: COOKIE_DOMAIN,\n        httpOnly: true,\n        secure: true,\n        sameSite: 'Lax'\n      });\n    });\n  });\n\n  describe('GET /auth/auth0/callback', () => {\n    const email = 'new@user.com';\n    let getAccessTokenFromAuthorizationCodeFlowSpy: MockInstance;\n    let userinfoSpy: MockInstance;\n\n    const mockAuthSuccess = () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockResolvedValueOnce({\n        token: 'any token'\n      });\n      userinfoSpy.mockResolvedValueOnce(Promise.resolve({ email }));\n    };\n\n    beforeEach(() => {\n      getAccessTokenFromAuthorizationCodeFlowSpy = vi.spyOn(\n        fastify.auth0OAuth,\n        'getAccessTokenFromAuthorizationCodeFlow'\n      );\n      userinfoSpy = vi.spyOn(fastify.auth0OAuth, 'userinfo');\n      // @ts-expect-error - Only mocks part of the Sentry object.\n      fastify.Sentry = { captureException: () => '' };\n    });\n\n    afterEach(async () => {\n      vi.restoreAllMocks();\n      await fastify.prisma.user.deleteMany({ where: { email } });\n    });\n\n    test('should redirect to the client if authentication fails', async () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockRejectedValueOnce(\n        'any error'\n      );\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback'\n      });\n\n      expect(res.headers.location).toMatch(\n        `${HOME_LOCATION}/?${formatMessage({ type: 'danger', content: 'flash.generic-error' })}`\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should redirect to the client if the state is invalid', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(res.headers.location).toMatch(\n        `${HOME_LOCATION}/?${formatMessage({ type: 'danger', content: 'flash.generic-error' })}`\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should log an error if the state is invalid', async () => {\n      vi.spyOn(fastify.log, 'error');\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(fastify.log.error).toHaveBeenCalledWith(\n        'Auth failed: invalid state'\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should log expected Auth0 errors', async () => {\n      vi.spyOn(fastify.log, 'error');\n      const auth0Error = Error('Response Error: 403 Forbidden');\n      // @ts-expect-error - mocking a hapi/boom error\n      auth0Error.data = {\n        payload: {\n          error: 'invalid_grant'\n        }\n      };\n\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockRejectedValueOnce(\n        auth0Error\n      );\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(fastify.log.error).toHaveBeenCalledWith(\n        auth0Error,\n        'Auth failed: invalid_grant'\n      );\n\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should not create a user if the state is invalid', async () => {\n      await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=invalid'\n      });\n\n      expect(await fastify.prisma.user.count()).toBe(0);\n    });\n\n    test('should block requests with \"access_denied\" error', async () => {\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?error=access_denied&error_description=Access denied from your location'\n      });\n\n      expect(res.statusCode).toBe(302);\n      expect(res.headers.location).toMatch(`${HOME_LOCATION}/blocked`);\n\n      const resWithoutDescription = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?error=access_denied'\n      });\n\n      expect(resWithoutDescription.statusCode).toBe(302);\n      expect(resWithoutDescription.headers.location).toMatch(\n        `${HOME_LOCATION}/learn?messages=`\n      );\n    });\n\n    test('creates a user if the state is valid', async () => {\n      mockAuthSuccess();\n      await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      expect(await fastify.prisma.user.count()).toBe(1);\n    });\n\n    test('handles userinfo errors', async () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockResolvedValueOnce({\n        token: 'any token'\n      });\n      userinfoSpy.mockResolvedValueOnce(Promise.reject(Error('any error')));\n      const returnTo = 'https://www.freecodecamp.org/espanol/learn';\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': sign(returnTo) }\n      });\n\n      expect(res.headers.location).toMatch(\n        returnTo +\n          `?${formatMessage({ type: 'danger', content: 'flash.generic-error' })}`\n      );\n      expect(res.statusCode).toBe(302);\n      expect(await fastify.prisma.user.count()).toBe(0);\n    });\n\n    test('handles invalid userinfo responses', async () => {\n      getAccessTokenFromAuthorizationCodeFlowSpy.mockResolvedValueOnce({\n        token: 'any token'\n      });\n      userinfoSpy.mockResolvedValueOnce(Promise.resolve({}));\n      const returnTo = 'https://www.freecodecamp.org/espanol/learn';\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': sign(returnTo) }\n      });\n\n      expect(res.headers.location).toMatch(\n        returnTo +\n          `?${formatMessage({ type: 'danger', content: 'flash.no-email-in-userinfo' })}`\n      );\n      expect(res.statusCode).toBe(302);\n      expect(await fastify.prisma.user.count()).toBe(0);\n    });\n\n    test('redirects with the signin-success message on success', async () => {\n      mockAuthSuccess();\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      expect(res.headers.location).toMatch(\n        `?${formatMessage({ type: 'success', content: 'flash.signin-success' })}`\n      );\n      expect(res.statusCode).toBe(302);\n    });\n\n    test('should set the jwt_access_token cookie', async () => {\n      mockAuthSuccess();\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      expect(res.headers['set-cookie']).toEqual(\n        expect.stringMatching(/jwt_access_token=/)\n      );\n    });\n\n    test('should use the login-returnto cookie if present and valid', async () => {\n      mockAuthSuccess();\n      await fastify.prisma.user.create({\n        data: { ...createUserInput(email), acceptedPrivacyTerms: true }\n      });\n      const returnTo = 'https://www.freecodecamp.org/espanol/learn';\n      // /signin sets the cookie\n      const req = await fastify.inject({\n        method: 'GET',\n        url: '/signin',\n        headers: {\n          referer: returnTo\n        }\n      });\n      const returnToCookie = req.cookies.find(c => c.name === 'login-returnto');\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': returnToCookie!.value }\n      });\n\n      expect(res.headers.location).toBe(\n        `${returnTo}?${formatMessage({ type: 'success', content: 'flash.signin-success' })}`\n      );\n    });\n\n    test('should redirect to learn if the user has signed in from the landing page', async () => {\n      mockAuthSuccess();\n\n      const returnTo = 'https://www.freecodecamp.org/';\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: {\n          'login-returnto': sign(returnTo)\n        }\n      });\n\n      expect(res.headers.location).toEqual(\n        expect.stringContaining('https://www.freecodecamp.org/learn?')\n      );\n    });\n\n    test('should redirect home if the login-returnto cookie is invalid', async () => {\n      mockAuthSuccess();\n      const returnTo = 'https://www.evilcodecamp.org/espanol/learn';\n      // /signin sets the cookie\n      const req = await fastify.inject({\n        method: 'GET',\n        url: '/signin',\n        headers: {\n          referer: returnTo\n        }\n      });\n      const returnToCookie = req.cookies.find(c => c.name === 'login-returnto');\n\n      const res = await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid',\n        cookies: { 'login-returnto': returnToCookie!.value }\n      });\n\n      expect(res.headers.location).toMatch(HOME_LOCATION);\n    });\n\n    test('should populate the user with the correct data', async () => {\n      mockAuthSuccess();\n\n      await fastify.inject({\n        method: 'GET',\n        url: '/auth/auth0/callback?state=valid'\n      });\n\n      const user = await fastify.prisma.user.findFirstOrThrow({\n        where: { email }\n      });\n\n      expect(user).toEqual(newUser(email));\n      expect(user.username).toBe(user.usernameDisplay);\n    });\n  });\n});\n",
    "linesChanged": 17,
    "complexity": 12271,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "c5676e3145c62bbb000d47984fff95de019f8f1c",
      "author": "Jamesren64",
      "date": "2025-11-21T11:03:55Z",
      "file": "api/src/plugins/auth0.test.ts"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-c5676e3145c62bbb000d47984fff95de019f8f1c-api/src/plugins/auth0.ts",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import fastifyOauth2, { type OAuth2Namespace } from '@fastify/oauth2';\nimport { type FastifyPluginCallbackTypebox } from '@fastify/type-provider-typebox';\nimport { Type } from 'typebox';\nimport { Value } from 'typebox/value';\nimport fp from 'fastify-plugin';\n\nimport { isError } from 'lodash-es';\nimport {\n  API_LOCATION,\n  AUTH0_CLIENT_ID,\n  AUTH0_CLIENT_SECRET,\n  AUTH0_DOMAIN,\n  COOKIE_DOMAIN,\n  HOME_LOCATION\n} from '../utils/env.js';\nimport { findOrCreateUser } from '../routes/helpers/auth-helpers.js';\nimport { createAccessToken } from '../utils/tokens.js';\nimport { getLoginRedirectParams } from '../utils/redirection.js';\n\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    auth0OAuth: OAuth2Namespace;\n  }\n}\n\nconst Auth0ErrorSchema = Type.Object({\n  data: Type.Object({\n    payload: Type.Object({\n      error: Type.String()\n    })\n  })\n});\n\n/**\n * Fastify plugin for Auth0 authentication. This uses fastify-plugin to expose\n * the auth0OAuth decorator (for easier testing), but to maintain encapsulation\n * it should be registered in a plugin. That prevents auth0OAuth from being\n * available globally.\n *\n * @param fastify - The Fastify instance.\n * @param _options - The plugin options.\n * @param done - The callback function.\n */\nexport const auth0Client: FastifyPluginCallbackTypebox = fp(\n  (fastify, _options, done) => {\n    void fastify.register(fastifyOauth2, {\n      name: 'auth0OAuth',\n      scope: ['openid', 'email', 'profile'],\n      credentials: {\n        client: {\n          id: AUTH0_CLIENT_ID,\n          secret: AUTH0_CLIENT_SECRET\n        }\n      },\n      discovery: { issuer: `https://${AUTH0_DOMAIN}` },\n      callbackUri: `${API_LOCATION}/auth/auth0/callback`,\n      cookie: {\n        // It's important not to sign the cookie, since the OAuth2 plugin will\n        // not unsign it.\n        signed: false\n      }\n    });\n\n    void fastify.register(function (fastify, _options, done) {\n      // TODO(Post-MVP): move this into the app, so that we add this hook once for\n      // all auth routes.\n      fastify.addHook('onRequest', fastify.redirectIfSignedIn);\n\n      fastify.get('/signin', async function (request, reply) {\n        const returnTo = request.headers.referer ?? `${HOME_LOCATION}/learn`;\n        void reply.setCookie('login-returnto', returnTo, {\n          domain: COOKIE_DOMAIN,\n          httpOnly: true,\n          secure: true,\n          signed: true,\n          sameSite: 'lax'\n        });\n\n        const redirectUrl = await this.auth0OAuth.generateAuthorizationUri(\n          request,\n          reply\n        );\n        void reply.redirect(redirectUrl);\n      });\n\n      fastify.get('/signin/google', async function (request, reply) {\n        const returnTo = request.headers.referer ?? `${HOME_LOCATION}/learn`;\n        void reply.setCookie('login-returnto', returnTo, {\n          domain: COOKIE_DOMAIN,\n          httpOnly: true,\n          secure: true,\n          signed: true,\n          sameSite: 'lax'\n        });\n\n        const authorizationEndpoint =\n          await this.auth0OAuth.generateAuthorizationUri(request, reply);\n\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set('connection', 'google-oauth2');\n\n        void reply.redirect(url.toString());\n      });\n      done();\n    });\n\n    // TODO: use a schema to validate the query params.\n    fastify.get('/auth/auth0/callback', async function (req, reply) {\n      const logger = fastify.log.child({ req, res: reply });\n\n      const { error, error_description } = req.query as Record<string, string>;\n      if (error === 'access_denied') {\n        const blockedByLaw =\n          error_description === 'Access denied from your location';\n        if (blockedByLaw) {\n          logger.info('Access denied due to user location');\n          return reply.redirect(`${HOME_LOCATION}/blocked`);\n        } else {\n          logger.info('Authentication failed for user:' + error_description);\n          return reply.redirectWithMessage(`${HOME_LOCATION}/learn`, {\n            type: 'info',\n            content: error_description ?? 'Authentication failed'\n          });\n        }\n      }\n\n      const { returnTo } = getLoginRedirectParams(req);\n\n      let token;\n      try {\n        token = (\n          await this.auth0OAuth.getAccessTokenFromAuthorizationCodeFlow(req)\n        ).token;\n      } catch (error) {\n        // This is the plugin's error message. If it changes, we will either\n        // have to update the test or write custom state create/verify\n        // functions.\n        if (error instanceof Error && error.message === 'Invalid state') {\n          logger.error('Auth failed: invalid state');\n        } else if (Value.Check(Auth0ErrorSchema, error)) {\n          const errorType = error.data.payload.error;\n          logger.error(error, 'Auth failed: ' + errorType);\n        } else {\n          logger.error(error, 'Failed to get access token from Auth0');\n          fastify.Sentry.captureException(error);\n        }\n        // It's important _not_ to redirect to /signin here, as that could\n        // create an infinite loop.\n        return reply.redirectWithMessage(returnTo, {\n          type: 'danger',\n          content: 'flash.generic-error'\n        });\n      }\n\n      let email;\n      try {\n        const userinfo = (await fastify.auth0OAuth.userinfo(token)) as {\n          email: string;\n        };\n        logger.info(`Auth0 userinfo: ${JSON.stringify(userinfo)}`);\n        email = userinfo.email;\n        if (typeof email !== 'string') {\n          return reply.redirectWithMessage(returnTo, {\n            type: 'danger',\n            content: 'flash.no-email-in-userinfo'\n          });\n        }\n      } catch (error) {\n        logger.error(error, 'Failed to get userinfo from Auth0');\n        if (isError(error) && 'innerError' in error) {\n          // This is a specific error from the @fastify/oauth2 plugin.\n          const innerError = error.innerError as Error;\n          innerError.message = `Auth0 userinfo error: ${innerError.message}`;\n          fastify.Sentry.captureException(error.innerError);\n        } else {\n          fastify.Sentry.captureException(error);\n        }\n        return reply.redirectWithMessage(returnTo, {\n          type: 'danger',\n          content: 'flash.generic-error'\n        });\n      }\n\n      const { id } = await findOrCreateUser(fastify, email);\n\n      reply.setAccessTokenCookie(createAccessToken(id));\n\n      void reply.redirectWithMessage(returnTo, {\n        type: 'success',\n        content: 'flash.signin-success'\n      });\n    });\n\n    done();\n  },\n  // TODO(Post-MVP): remove bouncer dependency when moving redirectIfSignedIn\n  // out of this plugin.\n  { dependencies: ['redirect-with-message', 'bouncer'] }\n);\n",
    "afterCode": "import fastifyOauth2, { type OAuth2Namespace } from '@fastify/oauth2';\nimport { type FastifyPluginCallbackTypebox } from '@fastify/type-provider-typebox';\nimport { Type } from 'typebox';\nimport { Value } from 'typebox/value';\nimport fp from 'fastify-plugin';\n\nimport { isError } from 'lodash-es';\nimport {\n  API_LOCATION,\n  AUTH0_CLIENT_ID,\n  AUTH0_CLIENT_SECRET,\n  AUTH0_DOMAIN,\n  COOKIE_DOMAIN,\n  HOME_LOCATION\n} from '../utils/env.js';\nimport { findOrCreateUser } from '../routes/helpers/auth-helpers.js';\nimport { createAccessToken } from '../utils/tokens.js';\nimport { getLoginRedirectParams } from '../utils/redirection.js';\n\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    auth0OAuth: OAuth2Namespace;\n  }\n}\n\nconst Auth0ErrorSchema = Type.Object({\n  data: Type.Object({\n    payload: Type.Object({\n      error: Type.String()\n    })\n  })\n});\n\n/**\n * Fastify plugin for Auth0 authentication. This uses fastify-plugin to expose\n * the auth0OAuth decorator (for easier testing), but to maintain encapsulation\n * it should be registered in a plugin. That prevents auth0OAuth from being\n * available globally.\n *\n * @param fastify - The Fastify instance.\n * @param _options - The plugin options.\n * @param done - The callback function.\n */\nexport const auth0Client: FastifyPluginCallbackTypebox = fp(\n  (fastify, _options, done) => {\n    void fastify.register(fastifyOauth2, {\n      name: 'auth0OAuth',\n      scope: ['openid', 'email', 'profile'],\n      credentials: {\n        client: {\n          id: AUTH0_CLIENT_ID,\n          secret: AUTH0_CLIENT_SECRET\n        }\n      },\n      discovery: { issuer: `https://${AUTH0_DOMAIN}` },\n      callbackUri: `${API_LOCATION}/auth/auth0/callback`,\n      cookie: {\n        // It's important not to sign the cookie, since the OAuth2 plugin will\n        // not unsign it.\n        signed: false\n      }\n    });\n\n    void fastify.register(function (fastify, _options, done) {\n      // TODO(Post-MVP): move this into the app, so that we add this hook once for\n      // all auth routes.\n      fastify.addHook('onRequest', fastify.redirectIfSignedIn);\n\n      fastify.get('/signin', async function (request, reply) {\n        const returnTo = request.headers.referer ?? `${HOME_LOCATION}/learn`;\n        void reply.setCookie('login-returnto', returnTo, {\n          domain: COOKIE_DOMAIN,\n          httpOnly: true,\n          secure: true,\n          signed: true,\n          sameSite: 'lax'\n        });\n\n        const redirectUrl = await this.auth0OAuth.generateAuthorizationUri(\n          request,\n          reply\n        );\n        void reply.redirect(redirectUrl);\n      });\n\n      fastify.get('/signin/google', async function (request, reply) {\n        const returnTo = request.headers.referer ?? `${HOME_LOCATION}/learn`;\n        void reply.setCookie('login-returnto', returnTo, {\n          domain: COOKIE_DOMAIN,\n          httpOnly: true,\n          secure: true,\n          signed: true,\n          sameSite: 'lax'\n        });\n\n        const authorizationEndpoint =\n          await this.auth0OAuth.generateAuthorizationUri(request, reply);\n\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set('connection', 'google-oauth2');\n\n        void reply.redirect(url.toString());\n      });\n      done();\n    });\n\n    // TODO: use a schema to validate the query params.\n    fastify.get('/auth/auth0/callback', async function (req, reply) {\n      const logger = fastify.log.child({ req, res: reply });\n\n      const { error, error_description } = req.query as Record<string, string>;\n      if (error === 'access_denied') {\n        const blockedByLaw =\n          error_description === 'Access denied from your location';\n        if (blockedByLaw) {\n          logger.info('Access denied due to user location');\n          return reply.redirect(`${HOME_LOCATION}/blocked`);\n        } else {\n          logger.info('Authentication failed for user:' + error_description);\n          return reply.redirectWithMessage(`${HOME_LOCATION}/learn`, {\n            type: 'info',\n            content: error_description ?? 'Authentication failed'\n          });\n        }\n      }\n\n      const { returnTo, origin } = getLoginRedirectParams(req);\n\n      let token;\n      try {\n        token = (\n          await this.auth0OAuth.getAccessTokenFromAuthorizationCodeFlow(req)\n        ).token;\n      } catch (error) {\n        // This is the plugin's error message. If it changes, we will either\n        // have to update the test or write custom state create/verify\n        // functions.\n        if (error instanceof Error && error.message === 'Invalid state') {\n          logger.error('Auth failed: invalid state');\n        } else if (Value.Check(Auth0ErrorSchema, error)) {\n          const errorType = error.data.payload.error;\n          logger.error(error, 'Auth failed: ' + errorType);\n        } else {\n          logger.error(error, 'Failed to get access token from Auth0');\n          fastify.Sentry.captureException(error);\n        }\n        // It's important _not_ to redirect to /signin here, as that could\n        // create an infinite loop.\n        return reply.redirectWithMessage(returnTo, {\n          type: 'danger',\n          content: 'flash.generic-error'\n        });\n      }\n\n      let email;\n      try {\n        const userinfo = (await fastify.auth0OAuth.userinfo(token)) as {\n          email: string;\n        };\n        logger.info(`Auth0 userinfo: ${JSON.stringify(userinfo)}`);\n        email = userinfo.email;\n        if (typeof email !== 'string') {\n          return reply.redirectWithMessage(returnTo, {\n            type: 'danger',\n            content: 'flash.no-email-in-userinfo'\n          });\n        }\n      } catch (error) {\n        logger.error(error, 'Failed to get userinfo from Auth0');\n        if (isError(error) && 'innerError' in error) {\n          // This is a specific error from the @fastify/oauth2 plugin.\n          const innerError = error.innerError as Error;\n          innerError.message = `Auth0 userinfo error: ${innerError.message}`;\n          fastify.Sentry.captureException(error.innerError);\n        } else {\n          fastify.Sentry.captureException(error);\n        }\n        return reply.redirectWithMessage(returnTo, {\n          type: 'danger',\n          content: 'flash.generic-error'\n        });\n      }\n\n      const { id } = await findOrCreateUser(fastify, email);\n\n      reply.setAccessTokenCookie(createAccessToken(id));\n\n      const returnPath = new URL(returnTo).pathname;\n      const returnURL = returnPath === '/' ? `${origin}/learn` : returnTo;\n\n      void reply.redirectWithMessage(returnURL, {\n        type: 'success',\n        content: 'flash.signin-success'\n      });\n    });\n\n    done();\n  },\n  // TODO(Post-MVP): remove bouncer dependency when moving redirectIfSignedIn\n  // out of this plugin.\n  { dependencies: ['redirect-with-message', 'bouncer'] }\n);\n",
    "linesChanged": 7,
    "complexity": 6872,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "c5676e3145c62bbb000d47984fff95de019f8f1c",
      "author": "Jamesren64",
      "date": "2025-11-21T11:03:55Z",
      "file": "api/src/plugins/auth0.ts"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-02928e10cb2b0cdcbf43354a3e98b7cb437d2207-client/src/templates/Challenges/exam-download/show.tsx",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import React, { useEffect, useState } from 'react';\nimport { graphql } from 'gatsby';\nimport Helmet from 'react-helmet';\nimport {\n  Button,\n  Callout,\n  Dropdown,\n  MenuItem,\n  Spacer,\n  Container,\n  Row,\n  Col\n} from '@freecodecamp/ui';\nimport { isEmpty } from 'lodash';\nimport { useTranslation, withTranslation } from 'react-i18next';\nimport { createSelector } from 'reselect';\nimport { connect } from 'react-redux';\n\nimport LearnLayout from '../../../components/layouts/learn';\nimport ChallengeTitle from '../components/challenge-title';\nimport useDetectOS from '../utils/use-detect-os';\nimport {\n  ChallengeNode,\n  CompletedChallenge,\n  User\n} from '../../../redux/prop-types';\nimport {\n  completedChallengesSelector,\n  isSignedInSelector,\n  userSelector\n} from '../../../redux/selectors';\nimport { examAttempts } from '../../../utils/ajax';\nimport MissingPrerequisites from '../exam/components/missing-prerequisites';\nimport { isChallengeCompletedSelector } from '../redux/selectors';\nimport { Attempts } from './attempts';\nimport ExamTokenControls from './exam-token-controls';\n\nimport './show.css';\n\ninterface GitProps {\n  tag_name: string;\n  assets: {\n    browser_download_url: string;\n  }[];\n}\n\nconst mapStateToProps = createSelector(\n  completedChallengesSelector,\n  isChallengeCompletedSelector,\n  isSignedInSelector,\n  userSelector,\n  (\n    completedChallenges: CompletedChallenge[],\n    isChallengeCompleted: boolean,\n    isSignedIn: boolean,\n    user: User | null\n  ) => ({\n    completedChallenges,\n    isChallengeCompleted,\n    isSignedIn,\n    user\n  })\n);\n\ninterface ShowExamDownloadProps {\n  data: {\n    challengeNode: ChallengeNode;\n    allChallengeNode: { nodes: ChallengeNode[] };\n  };\n  completedChallenges: CompletedChallenge[];\n  isChallengeCompleted: boolean;\n  isSignedIn: boolean;\n  user: User | null;\n}\n\nfunction ShowExamDownload({\n  data: {\n    challengeNode: {\n      challenge: { id, superBlock: examSuperBlock, title, translationPending }\n    },\n    allChallengeNode: { nodes }\n  },\n  completedChallenges,\n  isChallengeCompleted,\n  isSignedIn,\n  user\n}: ShowExamDownloadProps): JSX.Element {\n  const [latestVersion, setLatestVersion] = useState<string | null>(null);\n\n  const [downloadLink, setDownloadLink] = useState<string | undefined>('');\n  const [downloadLinks, setDownloadLinks] = useState<string[]>([]);\n\n  const getExamsQuery = examAttempts.useGetExamsQuery(undefined, {\n    skip: !isSignedIn\n  });\n  const examIdsQuery = examAttempts.useGetExamIdsByChallengeIdQuery(id, {\n    skip: !isSignedIn\n  });\n\n  const os = useDetectOS();\n\n  const { t } = useTranslation();\n\n  function handleDownloadLink(downloadLinks: string[]) {\n    const win = downloadLinks.find(link => link.match(/\\.exe/));\n    const macARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/\\.dmg/)\n    );\n    const macX64 = downloadLinks.find(\n      link => link.match(/x64/) && link.match(/\\.dmg/)\n    );\n\n    const linuxARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/tar\\.gz/)\n    );\n\n    const linuxX64 = downloadLinks.find(\n      link => link.match(/amd64/) && link.match(/AppImage/)\n    );\n\n    if (os.os === 'WIN') {\n      if (isEmpty(win)) return '';\n\n      return win;\n    }\n\n    if (os.os === 'MAC') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(macARM)) return '';\n\n        return macARM;\n      } else {\n        if (isEmpty(macX64)) return '';\n\n        return macX64;\n      }\n    }\n\n    if (os.os === 'LINUX') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(linuxARM)) return '';\n\n        return linuxARM;\n      } else {\n        if (isEmpty(linuxX64)) return '';\n\n        return linuxX64;\n      }\n    }\n\n    return '';\n  }\n\n  useEffect(() => {\n    async function checkLatestVersion() {\n      try {\n        const response = await fetch(\n          'https://api.github.com/repos/freeCodeCamp/exam-env/releases/latest'\n        );\n        if (response.ok) {\n          const data = (await response.json()) as GitProps;\n          const { tag_name, assets } = data;\n          setLatestVersion(tag_name);\n          const urls = assets.map(link => link.browser_download_url);\n          setDownloadLink(handleDownloadLink(urls));\n          setDownloadLinks(urls);\n        }\n      } catch {\n        setLatestVersion('...');\n      }\n    }\n\n    void checkLatestVersion();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [os]);\n\n  const examId = examIdsQuery.data?.at(0)?.examId;\n  const exam = getExamsQuery.data?.find(examItem => examItem.id === examId);\n  const unmetPrerequisites = exam?.prerequisites?.filter(\n    prereq => !completedChallenges.some(challenge => challenge.id === prereq)\n  );\n  const challenges = nodes.filter(\n    ({ challenge }) =>\n      unmetPrerequisites?.includes(challenge.id) &&\n      challenge.superBlock === examSuperBlock\n  );\n  const missingPrerequisites = challenges.map(({ challenge }) => {\n    return {\n      id: challenge.id,\n      title: challenge.title,\n      slug: challenge.fields?.slug || ''\n    };\n  });\n\n  return (\n    <LearnLayout>\n      <Helmet>\n        <title>\n          {title ? `${title} | freeCodeCamp.org` : 'freeCodeCamp.org'}\n        </title>\n      </Helmet>\n      <Container>\n        <Row>\n          <Col md={8} mdOffset={2} sm={10} smOffset={1} xs={12}>\n            <Spacer size='m' />\n            <ChallengeTitle\n              isCompleted={isChallengeCompleted}\n              translationPending={translationPending}\n            >\n              {title}\n            </ChallengeTitle>\n            <Spacer size='m' />\n            {missingPrerequisites.length > 0 ? (\n              <MissingPrerequisites\n                missingPrerequisites={missingPrerequisites}\n              />\n            ) : (\n              <Callout className='exam-qualified' variant='info'>\n                <p>{t('learn.exam.qualified')}</p>\n              </Callout>\n            )}\n            <h2>{t('exam.download-header')}</h2>\n            <p>{t('exam.explanation')}</p>\n            <Spacer size='l' />\n            {isSignedIn && (\n              <>\n                <h2>{t('exam.attempts')}</h2>\n                <Attempts examChallengeId={id} />\n                <Spacer size='l' />\n                <ExamTokenControls email={user!.email} />\n              </>\n            )}\n            <p>\n              {t('exam.version', {\n                version: latestVersion || '...'\n              })}\n            </p>\n            {/* TODO: confirm this works on MacOS */}\n            <Button href={'exam-environment://'}>\n              {t('exam.open-exam-application')}\n            </Button>\n            <Spacer size='s' />\n            <div className='exam-download-buttons'>\n              {downloadLink ? (\n                <Button href={downloadLink} download={downloadLink}>\n                  {t('buttons.download-latest-version')}\n                </Button>\n              ) : (\n                <strong>{t('exam.unable-to-detect-os')}</strong>\n              )}\n            </div>\n            <Spacer size='xs' />\n            <Dropdown dropup>\n              <Dropdown.Toggle>{t('exam.download-details')}</Dropdown.Toggle>\n              <Dropdown.Menu>\n                {downloadLinks\n                  .filter(link => !link.match(/\\.sig|\\.json/))\n                  .map((link, index) => {\n                    const urlEnd = link.split('/').pop() ?? '';\n                    return (\n                      <MenuItem\n                        href={link}\n                        download={link}\n                        key={index}\n                        variant='primary'\n                      >\n                        {urlEnd}\n                      </MenuItem>\n                    );\n                  })}\n              </Dropdown.Menu>\n            </Dropdown>\n            <Spacer size='l' />\n            <strong>{t('exam.download-trouble')}</strong>{' '}\n            <a href='mailto: support@freecodecamp.org'>\n              support@freecodecamp.org\n            </a>\n            <Spacer size='l' />\n          </Col>\n        </Row>\n      </Container>\n    </LearnLayout>\n  );\n}\n\nexport default connect(mapStateToProps)(withTranslation()(ShowExamDownload));\n\n// GraphQL\nexport const query = graphql`\n  query ExamEnvironmentExam($id: String!) {\n    challengeNode(id: { eq: $id }) {\n      challenge {\n        id\n        superBlock\n        title\n        translationPending\n      }\n    }\n    allChallengeNode {\n      nodes {\n        challenge {\n          id\n          title\n          fields {\n            slug\n          }\n          superBlock\n        }\n      }\n    }\n  }\n`;\n",
    "afterCode": "import React, { useEffect, useState } from 'react';\nimport { graphql } from 'gatsby';\nimport Helmet from 'react-helmet';\nimport {\n  Button,\n  Callout,\n  Dropdown,\n  MenuItem,\n  Spacer,\n  Container,\n  Row,\n  Col\n} from '@freecodecamp/ui';\nimport { isEmpty } from 'lodash';\nimport { useTranslation, withTranslation } from 'react-i18next';\nimport { createSelector } from 'reselect';\nimport { connect } from 'react-redux';\n\nimport LearnLayout from '../../../components/layouts/learn';\nimport ChallengeTitle from '../components/challenge-title';\nimport useDetectOS from '../utils/use-detect-os';\nimport {\n  ChallengeNode,\n  CompletedChallenge,\n  User\n} from '../../../redux/prop-types';\nimport {\n  completedChallengesSelector,\n  isSignedInSelector,\n  userSelector\n} from '../../../redux/selectors';\nimport { examAttempts } from '../../../utils/ajax';\nimport MissingPrerequisites from '../exam/components/missing-prerequisites';\nimport { isChallengeCompletedSelector } from '../redux/selectors';\nimport envData from '../../../../config/env.json';\nimport { Attempts } from './attempts';\nimport ExamTokenControls from './exam-token-controls';\n\nimport './show.css';\n\nconst { deploymentEnv } = envData;\n\ninterface GitProps {\n  tag_name: string;\n  assets: {\n    browser_download_url: string;\n  }[];\n  name: string;\n  draft: boolean;\n  prerelease: boolean;\n}\n\nconst mapStateToProps = createSelector(\n  completedChallengesSelector,\n  isChallengeCompletedSelector,\n  isSignedInSelector,\n  userSelector,\n  (\n    completedChallenges: CompletedChallenge[],\n    isChallengeCompleted: boolean,\n    isSignedIn: boolean,\n    user: User | null\n  ) => ({\n    completedChallenges,\n    isChallengeCompleted,\n    isSignedIn,\n    user\n  })\n);\n\ninterface ShowExamDownloadProps {\n  data: {\n    challengeNode: ChallengeNode;\n    allChallengeNode: { nodes: ChallengeNode[] };\n  };\n  completedChallenges: CompletedChallenge[];\n  isChallengeCompleted: boolean;\n  isSignedIn: boolean;\n  user: User | null;\n}\n\nfunction ShowExamDownload({\n  data: {\n    challengeNode: {\n      challenge: { id, superBlock: examSuperBlock, title, translationPending }\n    },\n    allChallengeNode: { nodes }\n  },\n  completedChallenges,\n  isChallengeCompleted,\n  isSignedIn,\n  user\n}: ShowExamDownloadProps): JSX.Element {\n  const [latestVersion, setLatestVersion] = useState<string | null>(null);\n\n  const [downloadLink, setDownloadLink] = useState<string | undefined>('');\n  const [downloadLinks, setDownloadLinks] = useState<string[]>([]);\n\n  const getExamsQuery = examAttempts.useGetExamsQuery(undefined, {\n    skip: !isSignedIn\n  });\n  const examIdsQuery = examAttempts.useGetExamIdsByChallengeIdQuery(id, {\n    skip: !isSignedIn\n  });\n\n  const os = useDetectOS();\n\n  const { t } = useTranslation();\n\n  function handleDownloadLink(downloadLinks: string[]) {\n    const win = downloadLinks.find(link => link.match(/\\.exe/));\n    const macARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/\\.dmg/)\n    );\n    const macX64 = downloadLinks.find(\n      link => link.match(/x64/) && link.match(/\\.dmg/)\n    );\n\n    const linuxARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/tar\\.gz/)\n    );\n\n    const linuxX64 = downloadLinks.find(\n      link => link.match(/amd64/) && link.match(/AppImage/)\n    );\n\n    if (os.os === 'WIN') {\n      if (isEmpty(win)) return '';\n\n      return win;\n    }\n\n    if (os.os === 'MAC') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(macARM)) return '';\n\n        return macARM;\n      } else {\n        if (isEmpty(macX64)) return '';\n\n        return macX64;\n      }\n    }\n\n    if (os.os === 'LINUX') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(linuxARM)) return '';\n\n        return linuxARM;\n      } else {\n        if (isEmpty(linuxX64)) return '';\n\n        return linuxX64;\n      }\n    }\n\n    return '';\n  }\n\n  useEffect(() => {\n    async function checkLatestVersion() {\n      try {\n        let latest: GitProps;\n\n        if (deploymentEnv !== 'production') {\n          const response = await fetch(\n            'https://api.github.com/repos/freeCodeCamp/exam-env/releases'\n          );\n\n          if (!response.ok) {\n            setLatestVersion(null);\n            return;\n          }\n\n          const data = (await response.json()) as GitProps[];\n          if (!data || data.length === 0) {\n            setLatestVersion(null);\n            return;\n          }\n          latest = getLatest(data);\n        } else {\n          const response = await fetch(\n            'https://api.github.com/repos/freeCodeCamp/exam-env/releases/latest'\n          );\n          if (!response.ok) {\n            setLatestVersion(null);\n            return;\n          }\n          const data = (await response.json()) as GitProps;\n          if (!data) {\n            setLatestVersion(null);\n            return;\n          }\n          latest = data;\n        }\n\n        const { tag_name, assets } = latest;\n        setLatestVersion(tag_name);\n        const urls = assets.map(link => link.browser_download_url);\n        setDownloadLink(handleDownloadLink(urls));\n        setDownloadLinks(urls);\n      } catch {\n        setLatestVersion(null);\n      }\n    }\n\n    if (os.os) {\n      void checkLatestVersion();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [os]);\n\n  const examId = examIdsQuery.data?.at(0)?.examId;\n  const exam = getExamsQuery.data?.find(examItem => examItem.id === examId);\n  const unmetPrerequisites = exam?.prerequisites?.filter(\n    prereq => !completedChallenges.some(challenge => challenge.id === prereq)\n  );\n  const challenges = nodes.filter(\n    ({ challenge }) =>\n      unmetPrerequisites?.includes(challenge.id) &&\n      challenge.superBlock === examSuperBlock\n  );\n  const missingPrerequisites = challenges.map(({ challenge }) => {\n    return {\n      id: challenge.id,\n      title: challenge.title,\n      slug: challenge.fields?.slug || ''\n    };\n  });\n\n  return (\n    <LearnLayout>\n      <Helmet>\n        <title>\n          {title ? `${title} | freeCodeCamp.org` : 'freeCodeCamp.org'}\n        </title>\n      </Helmet>\n      <Container>\n        <Row>\n          <Col md={8} mdOffset={2} sm={10} smOffset={1} xs={12}>\n            <Spacer size='m' />\n            <ChallengeTitle\n              isCompleted={isChallengeCompleted}\n              translationPending={translationPending}\n            >\n              {title}\n            </ChallengeTitle>\n            <Spacer size='m' />\n            {missingPrerequisites.length > 0 ? (\n              <MissingPrerequisites\n                missingPrerequisites={missingPrerequisites}\n              />\n            ) : (\n              <Callout className='exam-qualified' variant='info'>\n                <p>{t('learn.exam.qualified')}</p>\n              </Callout>\n            )}\n            <h2>{t('exam.download-header')}</h2>\n            <p>{t('exam.explanation')}</p>\n            <Spacer size='l' />\n            {isSignedIn && (\n              <>\n                <h2>{t('exam.attempts')}</h2>\n                <Attempts examChallengeId={id} />\n                <Spacer size='l' />\n                <ExamTokenControls email={user!.email} />\n              </>\n            )}\n            <p>\n              {t('exam.version', {\n                version: latestVersion || '...'\n              })}\n            </p>\n            <Button href={'exam-environment://'}>\n              {t('exam.open-exam-application')}\n            </Button>\n            <Spacer size='s' />\n            <div className='exam-download-buttons'>\n              {downloadLink ? (\n                <Button href={downloadLink} download={downloadLink}>\n                  {t('buttons.download-latest-version')}\n                </Button>\n              ) : (\n                <strong>{t('exam.unable-to-detect-os')}</strong>\n              )}\n            </div>\n            <Spacer size='xs' />\n            <Dropdown dropup>\n              <Dropdown.Toggle>{t('exam.download-details')}</Dropdown.Toggle>\n              <Dropdown.Menu>\n                {downloadLinks\n                  .filter(link => !link.match(/\\.sig|\\.json/))\n                  .map((link, index) => {\n                    const urlEnd = link.split('/').pop() ?? '';\n                    return (\n                      <MenuItem\n                        href={link}\n                        download={link}\n                        key={index}\n                        variant='primary'\n                      >\n                        {urlEnd}\n                      </MenuItem>\n                    );\n                  })}\n              </Dropdown.Menu>\n            </Dropdown>\n            <Spacer size='l' />\n            <strong>{t('exam.download-trouble')}</strong>{' '}\n            <a href='mailto: support@freecodecamp.org'>\n              support@freecodecamp.org\n            </a>\n            <Spacer size='l' />\n          </Col>\n        </Row>\n      </Container>\n    </LearnLayout>\n  );\n}\n\nfunction getLatest(releases: GitProps[]): GitProps {\n  switch (deploymentEnv) {\n    case 'staging':\n      return (\n        releases.find(r => {\n          return !r.draft && r.name.endsWith('/staging');\n        }) || releases[0]\n      );\n    // Currently, this is never the case\n    case 'development':\n      return (\n        releases.find(r => {\n          return !r.draft && r.name.endsWith('/development');\n        }) || releases[0]\n      );\n    default:\n      return (\n        releases.find(r => {\n          return !r.prerelease && !r.draft && r.name.endsWith('/production');\n        }) || releases[0]\n      );\n  }\n}\n\nexport default connect(mapStateToProps)(withTranslation()(ShowExamDownload));\n\n// GraphQL\nexport const query = graphql`\n  query ExamEnvironmentExam($id: String!) {\n    challengeNode(id: { eq: $id }) {\n      challenge {\n        id\n        superBlock\n        title\n        translationPending\n      }\n    }\n    allChallengeNode {\n      nodes {\n        challenge {\n          id\n          title\n          fields {\n            slug\n          }\n          superBlock\n        }\n      }\n    }\n  }\n`;\n",
    "linesChanged": 83,
    "complexity": 10083,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "02928e10cb2b0cdcbf43354a3e98b7cb437d2207",
      "author": "Shaun Hamilton",
      "date": "2025-11-19T19:55:54Z",
      "file": "client/src/templates/Challenges/exam-download/show.tsx"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-0367c2ddb152f5ede1575cbc1d92134c35de2957-client/src/client-only-routes/show-settings.tsx",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import React, { useRef, useEffect } from 'react';\nimport Helmet from 'react-helmet';\nimport { useTranslation } from 'react-i18next';\nimport { connect } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport { scroller } from 'react-scroll';\n\nimport { Container, Spacer } from '@freecodecamp/ui';\nimport { useFeatureIsOn } from '@growthbook/growthbook-react';\n\nimport store from 'store';\nimport envData from '../../config/env.json';\nimport { createFlashMessage } from '../components/Flash/redux';\nimport { Loader } from '../components/helpers';\nimport Certification from '../components/settings/certification';\nimport MiscSettings from '../components/settings/misc-settings';\nimport DangerZone from '../components/settings/danger-zone';\nimport Email from '../components/settings/email';\nimport Honesty from '../components/settings/honesty';\nimport Privacy from '../components/settings/privacy';\nimport UserToken from '../components/settings/user-token';\nimport ExamToken from '../components/settings/exam-token';\nimport { hardGoTo as navigate } from '../redux/actions';\nimport {\n  signInLoadingSelector,\n  userSelector,\n  isSignedInSelector,\n  userTokenSelector\n} from '../redux/selectors';\nimport type { User } from '../redux/prop-types';\nimport {\n  submitNewAbout,\n  updateMyHonesty,\n  updateMyQuincyEmail,\n  updateMySound,\n  updateMyKeyboardShortcuts,\n  verifyCert,\n  resetMyEditorLayout\n} from '../redux/settings/actions';\n\nconst { apiLocation } = envData;\n\n// TODO: update types for actions\ntype ShowSettingsProps = {\n  createFlashMessage: typeof createFlashMessage;\n  isSignedIn: boolean;\n  navigate: (location: string) => void;\n  showLoading: boolean;\n  toggleSoundMode: (sound: boolean) => void;\n  resetEditorLayout: () => void;\n  toggleKeyboardShortcuts: (keyboardShortcuts: boolean) => void;\n  updateIsHonest: () => void;\n  updateQuincyEmail: (isSendQuincyEmail: boolean) => void;\n  user: User | null;\n  verifyCert: typeof verifyCert;\n  path?: string;\n  userToken: string | null;\n};\n\nconst mapStateToProps = createSelector(\n  signInLoadingSelector,\n  userSelector,\n  isSignedInSelector,\n  userTokenSelector,\n  (\n    showLoading: boolean,\n    user: User | null,\n    isSignedIn,\n    userToken: string | null\n  ) => ({\n    showLoading,\n    user,\n    isSignedIn,\n    userToken\n  })\n);\n\nconst mapDispatchToProps = {\n  createFlashMessage,\n  navigate,\n  submitNewAbout,\n  toggleSoundMode: (sound: boolean) => updateMySound({ sound }),\n  toggleKeyboardShortcuts: (keyboardShortcuts: boolean) =>\n    updateMyKeyboardShortcuts({ keyboardShortcuts }),\n  updateIsHonest: updateMyHonesty,\n  updateQuincyEmail: (sendQuincyEmail: boolean) =>\n    updateMyQuincyEmail({ sendQuincyEmail }),\n  resetEditorLayout: () => resetMyEditorLayout(),\n  verifyCert\n};\n\nexport function ShowSettings(props: ShowSettingsProps): JSX.Element {\n  const { t } = useTranslation();\n  const {\n    createFlashMessage,\n    isSignedIn,\n    toggleSoundMode,\n    toggleKeyboardShortcuts,\n    resetEditorLayout,\n    user,\n    navigate,\n    showLoading,\n    updateQuincyEmail,\n    updateIsHonest,\n    verifyCert,\n    userToken\n  } = props;\n\n  const isSignedInRef = useRef(isSignedIn);\n\n  const examTokenFlag = useFeatureIsOn('exam-token-widget');\n\n  const handleHashChange = () => {\n    const id = window.location.hash.replace('#', '');\n    if (id) {\n      scroller.scrollTo(id, {\n        smooth: true,\n        duration: 500,\n        offset: -100\n      });\n    }\n  };\n\n  useEffect(() => {\n    handleHashChange();\n\n    window.addEventListener('hashchange', handleHashChange);\n    return () => window.removeEventListener('hashchange', handleHashChange);\n  }, []);\n\n  if (showLoading || !user) {\n    return <Loader fullScreen={true} />;\n  }\n\n  if (!isSignedInRef.current) {\n    navigate(`${apiLocation}/signin`);\n    return <Loader fullScreen={true} />;\n  }\n\n  const {\n    completedChallenges,\n    email,\n    is2018DataVisCert,\n    isA2EnglishCert,\n    isApisMicroservicesCert,\n    isJavascriptCertV9,\n    isJsAlgoDataStructCert,\n    isBackEndCert,\n    isDataVisCert,\n    isFrontEndCert,\n    isInfosecQaCert,\n    isQaCertV7,\n    isInfosecCertV7,\n    isFrontEndLibsCert,\n    isFullStackCert,\n    isRespWebDesignCert,\n    isRespWebDesignCertV9,\n    isSciCompPyCertV7,\n    isDataAnalysisPyCertV7,\n    isMachineLearningPyCertV7,\n    isRelationalDatabaseCertV8,\n    isCollegeAlgebraPyCertV8,\n    isFoundationalCSharpCertV8,\n    isJsAlgoDataStructCertV8,\n    isEmailVerified,\n    isHonest,\n    sendQuincyEmail,\n    username,\n    keyboardShortcuts\n  } = user;\n\n  const sound = (store.get('fcc-sound') as boolean) ?? false;\n  const editorLayout = (store.get('challenge-layout') as boolean) ?? false;\n  return (\n    <>\n      <Helmet title={`${t('buttons.settings')} | freeCodeCamp.org`} />\n      <Container>\n        <main>\n          <Spacer size='l' />\n          <h1\n            id='content-start'\n            className='text-center'\n            style={{ overflowWrap: 'break-word' }}\n            data-playwright-test-label='settings-heading'\n          >\n            {t('settings.for', { username: username })}\n          </h1>\n          <MiscSettings\n            keyboardShortcuts={keyboardShortcuts}\n            sound={sound}\n            editorLayout={editorLayout}\n            resetEditorLayout={resetEditorLayout}\n            toggleKeyboardShortcuts={toggleKeyboardShortcuts}\n            toggleSoundMode={toggleSoundMode}\n          />\n          <Spacer size='m' />\n          <Privacy />\n          <Spacer size='m' />\n          <Email\n            email={email}\n            isEmailVerified={isEmailVerified}\n            sendQuincyEmail={sendQuincyEmail}\n            updateQuincyEmail={updateQuincyEmail}\n          />\n          <Spacer size='m' />\n          <Honesty isHonest={isHonest} updateIsHonest={updateIsHonest} />\n          <Spacer size='m' />\n          {examTokenFlag && <ExamToken />}\n          <Certification\n            completedChallenges={completedChallenges}\n            createFlashMessage={createFlashMessage}\n            is2018DataVisCert={is2018DataVisCert}\n            isA2EnglishCert={isA2EnglishCert}\n            isApisMicroservicesCert={isApisMicroservicesCert}\n            isBackEndCert={isBackEndCert}\n            isDataAnalysisPyCertV7={isDataAnalysisPyCertV7}\n            isDataVisCert={isDataVisCert}\n            isCollegeAlgebraPyCertV8={isCollegeAlgebraPyCertV8}\n            isFoundationalCSharpCertV8={isFoundationalCSharpCertV8}\n            isFrontEndCert={isFrontEndCert}\n            isFrontEndLibsCert={isFrontEndLibsCert}\n            isFullStackCert={isFullStackCert}\n            isJavascriptCertV9={isJavascriptCertV9}\n            isHonest={isHonest}\n            isInfosecCertV7={isInfosecCertV7}\n            isInfosecQaCert={isInfosecQaCert}\n            isJsAlgoDataStructCert={isJsAlgoDataStructCert}\n            isMachineLearningPyCertV7={isMachineLearningPyCertV7}\n            isQaCertV7={isQaCertV7}\n            isRelationalDatabaseCertV8={isRelationalDatabaseCertV8}\n            isRespWebDesignCert={isRespWebDesignCert}\n            isRespWebDesignCertV9={isRespWebDesignCertV9}\n            isSciCompPyCertV7={isSciCompPyCertV7}\n            isJsAlgoDataStructCertV8={isJsAlgoDataStructCertV8}\n            username={username}\n            verifyCert={verifyCert}\n            isEmailVerified={isEmailVerified}\n          />\n          {userToken && (\n            <>\n              <Spacer size='m' />\n              <UserToken />\n            </>\n          )}\n          <Spacer size='m' />\n          <DangerZone />\n        </main>\n      </Container>\n    </>\n  );\n}\n\nShowSettings.displayName = 'ShowSettings';\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ShowSettings);\n",
    "afterCode": "import React, { useRef, useEffect } from 'react';\nimport Helmet from 'react-helmet';\nimport { useTranslation } from 'react-i18next';\nimport { connect } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport { scroller } from 'react-scroll';\n\nimport { Container, Spacer } from '@freecodecamp/ui';\n\nimport store from 'store';\nimport envData from '../../config/env.json';\nimport { createFlashMessage } from '../components/Flash/redux';\nimport { Loader } from '../components/helpers';\nimport Certification from '../components/settings/certification';\nimport MiscSettings from '../components/settings/misc-settings';\nimport DangerZone from '../components/settings/danger-zone';\nimport Email from '../components/settings/email';\nimport Honesty from '../components/settings/honesty';\nimport Privacy from '../components/settings/privacy';\nimport UserToken from '../components/settings/user-token';\nimport ExamToken from '../components/settings/exam-token';\nimport { hardGoTo as navigate } from '../redux/actions';\nimport {\n  signInLoadingSelector,\n  userSelector,\n  isSignedInSelector,\n  userTokenSelector\n} from '../redux/selectors';\nimport type { User } from '../redux/prop-types';\nimport {\n  submitNewAbout,\n  updateMyHonesty,\n  updateMyQuincyEmail,\n  updateMySound,\n  updateMyKeyboardShortcuts,\n  verifyCert,\n  resetMyEditorLayout\n} from '../redux/settings/actions';\n\nconst { apiLocation } = envData;\n\n// TODO: update types for actions\ntype ShowSettingsProps = {\n  createFlashMessage: typeof createFlashMessage;\n  isSignedIn: boolean;\n  navigate: (location: string) => void;\n  showLoading: boolean;\n  toggleSoundMode: (sound: boolean) => void;\n  resetEditorLayout: () => void;\n  toggleKeyboardShortcuts: (keyboardShortcuts: boolean) => void;\n  updateIsHonest: () => void;\n  updateQuincyEmail: (isSendQuincyEmail: boolean) => void;\n  user: User | null;\n  verifyCert: typeof verifyCert;\n  path?: string;\n  userToken: string | null;\n};\n\nconst mapStateToProps = createSelector(\n  signInLoadingSelector,\n  userSelector,\n  isSignedInSelector,\n  userTokenSelector,\n  (\n    showLoading: boolean,\n    user: User | null,\n    isSignedIn,\n    userToken: string | null\n  ) => ({\n    showLoading,\n    user,\n    isSignedIn,\n    userToken\n  })\n);\n\nconst mapDispatchToProps = {\n  createFlashMessage,\n  navigate,\n  submitNewAbout,\n  toggleSoundMode: (sound: boolean) => updateMySound({ sound }),\n  toggleKeyboardShortcuts: (keyboardShortcuts: boolean) =>\n    updateMyKeyboardShortcuts({ keyboardShortcuts }),\n  updateIsHonest: updateMyHonesty,\n  updateQuincyEmail: (sendQuincyEmail: boolean) =>\n    updateMyQuincyEmail({ sendQuincyEmail }),\n  resetEditorLayout: () => resetMyEditorLayout(),\n  verifyCert\n};\n\nexport function ShowSettings(props: ShowSettingsProps): JSX.Element {\n  const { t } = useTranslation();\n  const {\n    createFlashMessage,\n    isSignedIn,\n    toggleSoundMode,\n    toggleKeyboardShortcuts,\n    resetEditorLayout,\n    user,\n    navigate,\n    showLoading,\n    updateQuincyEmail,\n    updateIsHonest,\n    verifyCert,\n    userToken\n  } = props;\n\n  const isSignedInRef = useRef(isSignedIn);\n\n  const handleHashChange = () => {\n    const id = window.location.hash.replace('#', '');\n    if (id) {\n      scroller.scrollTo(id, {\n        smooth: true,\n        duration: 500,\n        offset: -100\n      });\n    }\n  };\n\n  useEffect(() => {\n    handleHashChange();\n\n    window.addEventListener('hashchange', handleHashChange);\n    return () => window.removeEventListener('hashchange', handleHashChange);\n  }, []);\n\n  if (showLoading || !user) {\n    return <Loader fullScreen={true} />;\n  }\n\n  if (!isSignedInRef.current) {\n    navigate(`${apiLocation}/signin`);\n    return <Loader fullScreen={true} />;\n  }\n\n  const {\n    completedChallenges,\n    email,\n    is2018DataVisCert,\n    isA2EnglishCert,\n    isApisMicroservicesCert,\n    isJavascriptCertV9,\n    isJsAlgoDataStructCert,\n    isBackEndCert,\n    isDataVisCert,\n    isFrontEndCert,\n    isInfosecQaCert,\n    isQaCertV7,\n    isInfosecCertV7,\n    isFrontEndLibsCert,\n    isFullStackCert,\n    isRespWebDesignCert,\n    isRespWebDesignCertV9,\n    isSciCompPyCertV7,\n    isDataAnalysisPyCertV7,\n    isMachineLearningPyCertV7,\n    isRelationalDatabaseCertV8,\n    isCollegeAlgebraPyCertV8,\n    isFoundationalCSharpCertV8,\n    isJsAlgoDataStructCertV8,\n    isEmailVerified,\n    isHonest,\n    sendQuincyEmail,\n    username,\n    keyboardShortcuts\n  } = user;\n\n  const sound = (store.get('fcc-sound') as boolean) ?? false;\n  const editorLayout = (store.get('challenge-layout') as boolean) ?? false;\n  return (\n    <>\n      <Helmet title={`${t('buttons.settings')} | freeCodeCamp.org`} />\n      <Container>\n        <main>\n          <Spacer size='l' />\n          <h1\n            id='content-start'\n            className='text-center'\n            style={{ overflowWrap: 'break-word' }}\n            data-playwright-test-label='settings-heading'\n          >\n            {t('settings.for', { username: username })}\n          </h1>\n          <MiscSettings\n            keyboardShortcuts={keyboardShortcuts}\n            sound={sound}\n            editorLayout={editorLayout}\n            resetEditorLayout={resetEditorLayout}\n            toggleKeyboardShortcuts={toggleKeyboardShortcuts}\n            toggleSoundMode={toggleSoundMode}\n          />\n          <Spacer size='m' />\n          <Privacy />\n          <Spacer size='m' />\n          <Email\n            email={email}\n            isEmailVerified={isEmailVerified}\n            sendQuincyEmail={sendQuincyEmail}\n            updateQuincyEmail={updateQuincyEmail}\n          />\n          <Spacer size='m' />\n          <Honesty isHonest={isHonest} updateIsHonest={updateIsHonest} />\n          <Spacer size='m' />\n          <ExamToken email={email} />\n          <Certification\n            completedChallenges={completedChallenges}\n            createFlashMessage={createFlashMessage}\n            is2018DataVisCert={is2018DataVisCert}\n            isA2EnglishCert={isA2EnglishCert}\n            isApisMicroservicesCert={isApisMicroservicesCert}\n            isBackEndCert={isBackEndCert}\n            isDataAnalysisPyCertV7={isDataAnalysisPyCertV7}\n            isDataVisCert={isDataVisCert}\n            isCollegeAlgebraPyCertV8={isCollegeAlgebraPyCertV8}\n            isFoundationalCSharpCertV8={isFoundationalCSharpCertV8}\n            isFrontEndCert={isFrontEndCert}\n            isFrontEndLibsCert={isFrontEndLibsCert}\n            isFullStackCert={isFullStackCert}\n            isJavascriptCertV9={isJavascriptCertV9}\n            isHonest={isHonest}\n            isInfosecCertV7={isInfosecCertV7}\n            isInfosecQaCert={isInfosecQaCert}\n            isJsAlgoDataStructCert={isJsAlgoDataStructCert}\n            isMachineLearningPyCertV7={isMachineLearningPyCertV7}\n            isQaCertV7={isQaCertV7}\n            isRelationalDatabaseCertV8={isRelationalDatabaseCertV8}\n            isRespWebDesignCert={isRespWebDesignCert}\n            isRespWebDesignCertV9={isRespWebDesignCertV9}\n            isSciCompPyCertV7={isSciCompPyCertV7}\n            isJsAlgoDataStructCertV8={isJsAlgoDataStructCertV8}\n            username={username}\n            verifyCert={verifyCert}\n            isEmailVerified={isEmailVerified}\n          />\n          {userToken && (\n            <>\n              <Spacer size='m' />\n              <UserToken />\n            </>\n          )}\n          <Spacer size='m' />\n          <DangerZone />\n        </main>\n      </Container>\n    </>\n  );\n}\n\nShowSettings.displayName = 'ShowSettings';\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ShowSettings);\n",
    "linesChanged": 5,
    "complexity": 7561,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "0367c2ddb152f5ede1575cbc1d92134c35de2957",
      "author": "Shaun Hamilton",
      "date": "2025-11-19T19:48:09Z",
      "file": "client/src/client-only-routes/show-settings.tsx"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-0367c2ddb152f5ede1575cbc1d92134c35de2957-client/src/components/settings/exam-token.tsx",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import React, { useState } from 'react';\nimport { Button, Panel, Modal, Spacer } from '@freecodecamp/ui';\nimport { useTranslation } from 'react-i18next';\nimport { FullWidthRow } from '../helpers';\nimport { generateExamToken } from '../../utils/ajax';\n\nfunction ExamToken(): JSX.Element {\n  const [examToken, setExamToken] = useState<string | null>(null);\n  const [examTokenError, setExamTokenError] = useState<string | null>(null);\n\n  const [recentlyGenerated, setRecentlyGenerated] = useState(false);\n\n  const [copySuccess, setCopySuccess] = useState<string | null>(null);\n  const [copyError, setCopyError] = useState<string | null>(null);\n\n  const { t } = useTranslation();\n\n  const getToken = async () => {\n    try {\n      const response = await generateExamToken();\n\n      const {\n        data: { examEnvironmentAuthorizationToken }\n      } = response;\n      setExamToken(examEnvironmentAuthorizationToken);\n      setExamTokenError('');\n    } catch (_e) {\n      setExamTokenError(t('exam-token.error'));\n    }\n\n    setRecentlyGenerated(true);\n    setTimeout(() => setRecentlyGenerated(false), 10000);\n  };\n\n  return (\n    <FullWidthRow>\n      <Modal\n        open={!!examToken}\n        onClose={() => {\n          setExamToken(null);\n          setCopySuccess(null);\n          setCopyError(null);\n        }}\n      >\n        <Modal.Header>{t('exam-token.exam-token')}</Modal.Header>\n        <Modal.Body>\n          {examToken && (\n            <p style={{ wordBreak: 'break-word' }}>\n              {t('exam-token.your-exam-token', {\n                token: examToken\n              })}\n            </p>\n          )}\n          {examTokenError && <p style={{ color: 'red' }}>{examTokenError}</p>}\n          {copySuccess && <p style={{ color: 'green' }}>{copySuccess}</p>}\n          {copyError && <p style={{ color: 'red' }}>{copyError}</p>}\n        </Modal.Body>\n        <Modal.Footer>\n          <Button\n            onClick={() => {\n              navigator.clipboard.writeText(examToken ?? '').then(\n                () => {\n                  setCopySuccess(t('exam-token.copied'));\n                  setCopyError(null);\n                },\n                () => {\n                  setCopyError(t('exam-token.copy-error'));\n                  setCopySuccess(null);\n                }\n              );\n            }}\n          >\n            {t('buttons.copy')}\n          </Button>\n          <Spacer size='s' />\n          <Button\n            onClick={() => {\n              setExamToken(null);\n              setCopySuccess(null);\n              setCopyError(null);\n            }}\n          >\n            {t('buttons.close')}\n          </Button>\n        </Modal.Footer>\n      </Modal>\n      <Panel variant='info' id='exam-environment-authorization-token'>\n        <Panel.Heading>{t('exam-token.exam-token')}</Panel.Heading>\n        <Panel.Body>\n          <p>{t('exam-token.note')}</p>\n          <strong>{t('exam-token.invalidation-2')}</strong>\n          <Spacer size='s' />\n          <Button\n            block={true}\n            disabled={recentlyGenerated}\n            onClick={() => void getToken()}\n          >\n            {t('exam-token.generate-exam-token')}\n          </Button>\n        </Panel.Body>\n      </Panel>\n    </FullWidthRow>\n  );\n}\n\nExamToken.displayName = 'ExamToken';\n\nexport default ExamToken;\n",
    "afterCode": "import React, { useState } from 'react';\nimport { Button, Panel, Modal, Spacer } from '@freecodecamp/ui';\nimport { useTranslation } from 'react-i18next';\nimport { FullWidthRow } from '../helpers';\nimport { generateExamToken } from '../../utils/ajax';\nimport envData from '../../../config/env.json';\n\nconst { deploymentEnv } = envData;\n\ninterface ExamTokenProps {\n  email: string;\n}\n\nfunction ExamToken({ email }: ExamTokenProps) {\n  const [examToken, setExamToken] = useState<string | null>(null);\n  const [examTokenError, setExamTokenError] = useState<string | null>(null);\n\n  const [recentlyGenerated, setRecentlyGenerated] = useState(false);\n\n  const [copySuccess, setCopySuccess] = useState<string | null>(null);\n  const [copyError, setCopyError] = useState<string | null>(null);\n\n  const { t } = useTranslation();\n\n  const getToken = async () => {\n    try {\n      const response = await generateExamToken();\n\n      const {\n        data: { examEnvironmentAuthorizationToken }\n      } = response;\n      setExamToken(examEnvironmentAuthorizationToken);\n      setExamTokenError('');\n    } catch (_e) {\n      setExamTokenError(t('exam-token.error'));\n    }\n\n    setRecentlyGenerated(true);\n    setTimeout(() => setRecentlyGenerated(false), 10000);\n  };\n\n  const nonStaffTesting =\n    deploymentEnv !== 'production' && !email.endsWith('@freecodecamp.org');\n\n  return (\n    <FullWidthRow>\n      <Modal\n        open={!!examToken}\n        onClose={() => {\n          setExamToken(null);\n          setCopySuccess(null);\n          setCopyError(null);\n        }}\n      >\n        <Modal.Header>{t('exam-token.exam-token')}</Modal.Header>\n        <Modal.Body>\n          {examToken && (\n            <p style={{ wordBreak: 'break-word' }}>\n              {t('exam-token.your-exam-token', {\n                token: examToken\n              })}\n            </p>\n          )}\n          {examTokenError && <p style={{ color: 'red' }}>{examTokenError}</p>}\n          {copySuccess && <p style={{ color: 'green' }}>{copySuccess}</p>}\n          {copyError && <p style={{ color: 'red' }}>{copyError}</p>}\n        </Modal.Body>\n        <Modal.Footer>\n          <Button\n            onClick={() => {\n              navigator.clipboard.writeText(examToken ?? '').then(\n                () => {\n                  setCopySuccess(t('exam-token.copied'));\n                  setCopyError(null);\n                },\n                () => {\n                  setCopyError(t('exam-token.copy-error'));\n                  setCopySuccess(null);\n                }\n              );\n            }}\n          >\n            {t('buttons.copy')}\n          </Button>\n          <Spacer size='s' />\n          <Button\n            onClick={() => {\n              setExamToken(null);\n              setCopySuccess(null);\n              setCopyError(null);\n            }}\n          >\n            {t('buttons.close')}\n          </Button>\n        </Modal.Footer>\n      </Modal>\n      <Panel variant='info' id='exam-environment-authorization-token'>\n        <Panel.Heading>{t('exam-token.exam-token')}</Panel.Heading>\n        <Panel.Body>\n          <p>{t('exam-token.note')}</p>\n          <strong>{t('exam-token.invalidation-2')}</strong>\n          <Spacer size='s' />\n          {nonStaffTesting && <p>{t('exam-token.non-staff-testing')}</p>}\n          <Button\n            block={true}\n            disabled={recentlyGenerated || nonStaffTesting}\n            onClick={() => void getToken()}\n          >\n            {t('exam-token.generate-exam-token')}\n          </Button>\n        </Panel.Body>\n      </Panel>\n    </FullWidthRow>\n  );\n}\n\nExamToken.displayName = 'ExamToken';\n\nexport default ExamToken;\n",
    "linesChanged": 15,
    "complexity": 3642,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "0367c2ddb152f5ede1575cbc1d92134c35de2957",
      "author": "Shaun Hamilton",
      "date": "2025-11-19T19:48:09Z",
      "file": "client/src/components/settings/exam-token.tsx"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-0367c2ddb152f5ede1575cbc1d92134c35de2957-client/src/templates/Challenges/exam-download/exam-token-controls.tsx",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import React, { useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Button, Spacer } from '@freecodecamp/ui';\n\nimport { examEnvironmentAuthorizationTokenApi } from '../../../utils/ajax';\nimport { Loader } from '../../../components/helpers';\n\nexport function ExamTokenControls(): JSX.Element {\n  const { t } = useTranslation();\n\n  const [copySuccess, setCopySuccess] = useState<string | null>(null);\n  const [copyError, setCopyError] = useState<string | null>(null);\n\n  const [generateToken, generateMutation] =\n    examEnvironmentAuthorizationTokenApi.usePostGenerateExamEnvironmentAuthorizationTokenMutation();\n\n  const getTokenQuery =\n    examEnvironmentAuthorizationTokenApi.useGetExamEnvironmentAuthorizationTokenQuery();\n  const existingToken = getTokenQuery.data?.examEnvironmentAuthorizationToken;\n  const updatedToken = generateMutation.data?.examEnvironmentAuthorizationToken;\n  const token = updatedToken ?? existingToken;\n\n  function handleCopyExamToken() {\n    navigator.clipboard.writeText(token ?? '').then(\n      () => {\n        setCopySuccess(t('exam-token.copied'));\n        setCopyError(null);\n      },\n      () => {\n        setCopyError(t('exam-token.copy-error'));\n        setCopySuccess(null);\n      }\n    );\n  }\n\n  return (\n    <>\n      <h3>{t('exam-token.exam-token')}</h3>\n      <p>{t('exam-token.token-usage')}</p>\n      {generateMutation.isError && (\n        <p style={{ color: 'var(--danger-color)' }}>{t('exam-token.error')}</p>\n      )}\n      {generateMutation.isSuccess && (\n        <p style={{ color: 'var(--success-color)' }}>\n          {t('exam-token.generated')}\n        </p>\n      )}\n      {!!token && generateMutation.isSuccess && (\n        <p style={{ color: 'var(--yellow-color)' }}>\n          {t('exam-token.invalidation-2')}\n        </p>\n      )}\n      {!!token && !generateMutation.isSuccess && (\n        <p style={{ color: 'var(--yellow-color)' }}>\n          {t('exam-token.invalidation-1')}\n        </p>\n      )}\n      {getTokenQuery.isError && !token && (\n        <p style={{ color: 'var(--highlight-color)' }}>\n          {t('exam-token.no-token')}\n        </p>\n      )}\n      {generateMutation.isLoading || getTokenQuery.isLoading ? (\n        <Button block={true}>\n          <Loader />\n        </Button>\n      ) : (\n        <Button\n          block={true}\n          disabled={generateMutation.isLoading || getTokenQuery.isLoading}\n          onClick={() => void generateToken()}\n        >\n          {t('exam-token.generate-exam-token')}\n        </Button>\n      )}\n      <Spacer size='s' />\n      {copySuccess && (\n        <p style={{ color: 'var(--success-color)' }}>{copySuccess}</p>\n      )}\n      {copyError && <p style={{ color: 'var(--danger-color)' }}>{copyError}</p>}\n      {generateMutation.isLoading || getTokenQuery.isLoading ? (\n        <Button block={true}>\n          <Loader />\n        </Button>\n      ) : (\n        <Button block={true} disabled={!token} onClick={handleCopyExamToken}>\n          {t('exam-token.copy')}\n        </Button>\n      )}\n      <Spacer size='m' />\n    </>\n  );\n}\n\nexport default ExamTokenControls;\n",
    "afterCode": "import React, { useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Button, Spacer } from '@freecodecamp/ui';\n\nimport { examEnvironmentAuthorizationTokenApi } from '../../../utils/ajax';\nimport { Loader } from '../../../components/helpers';\nimport envData from '../../../../config/env.json';\n\nconst { deploymentEnv } = envData;\n\ninterface ExamTokenControlsProps {\n  email: string;\n}\n\nexport function ExamTokenControls({\n  email\n}: ExamTokenControlsProps): JSX.Element {\n  const { t } = useTranslation();\n\n  const [copySuccess, setCopySuccess] = useState<string | null>(null);\n  const [copyError, setCopyError] = useState<string | null>(null);\n\n  const [generateToken, generateMutation] =\n    examEnvironmentAuthorizationTokenApi.usePostGenerateExamEnvironmentAuthorizationTokenMutation();\n\n  const getTokenQuery =\n    examEnvironmentAuthorizationTokenApi.useGetExamEnvironmentAuthorizationTokenQuery();\n  const existingToken = getTokenQuery.data?.examEnvironmentAuthorizationToken;\n  const updatedToken = generateMutation.data?.examEnvironmentAuthorizationToken;\n  const token = updatedToken ?? existingToken;\n\n  function handleCopyExamToken() {\n    navigator.clipboard.writeText(token ?? '').then(\n      () => {\n        setCopySuccess(t('exam-token.copied'));\n        setCopyError(null);\n      },\n      () => {\n        setCopyError(t('exam-token.copy-error'));\n        setCopySuccess(null);\n      }\n    );\n  }\n\n  const nonStaffTesting =\n    deploymentEnv !== 'production' && !email.endsWith('@freecodecamp.org');\n\n  return (\n    <>\n      <h3>{t('exam-token.exam-token')}</h3>\n      <p>{t('exam-token.token-usage')}</p>\n      {generateMutation.isError && (\n        <p style={{ color: 'var(--danger-color)' }}>{t('exam-token.error')}</p>\n      )}\n      {generateMutation.isSuccess && (\n        <p style={{ color: 'var(--success-color)' }}>\n          {t('exam-token.generated')}\n        </p>\n      )}\n      {!!token && generateMutation.isSuccess && (\n        <p style={{ color: 'var(--yellow-color)' }}>\n          {t('exam-token.invalidation-2')}\n        </p>\n      )}\n      {!!token && !generateMutation.isSuccess && (\n        <p style={{ color: 'var(--yellow-color)' }}>\n          {t('exam-token.invalidation-1')}\n        </p>\n      )}\n      {getTokenQuery.isError && !token && (\n        <p style={{ color: 'var(--highlight-color)' }}>\n          {t('exam-token.no-token')}\n        </p>\n      )}\n      {nonStaffTesting && <p>{t('exam-token.non-staff-testing')}</p>}\n      {generateMutation.isLoading || getTokenQuery.isLoading ? (\n        <Button block={true}>\n          <Loader />\n        </Button>\n      ) : (\n        <Button\n          block={true}\n          disabled={\n            generateMutation.isLoading ||\n            getTokenQuery.isLoading ||\n            nonStaffTesting\n          }\n          onClick={() => void generateToken()}\n        >\n          {t('exam-token.generate-exam-token')}\n        </Button>\n      )}\n      <Spacer size='s' />\n      {copySuccess && (\n        <p style={{ color: 'var(--success-color)' }}>{copySuccess}</p>\n      )}\n      {copyError && <p style={{ color: 'var(--danger-color)' }}>{copyError}</p>}\n      {generateMutation.isLoading || getTokenQuery.isLoading ? (\n        <Button block={true}>\n          <Loader />\n        </Button>\n      ) : (\n        <Button block={true} disabled={!token} onClick={handleCopyExamToken}>\n          {t('exam-token.copy')}\n        </Button>\n      )}\n      <Spacer size='m' />\n    </>\n  );\n}\n\nexport default ExamTokenControls;\n",
    "linesChanged": 21,
    "complexity": 3527,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "0367c2ddb152f5ede1575cbc1d92134c35de2957",
      "author": "Shaun Hamilton",
      "date": "2025-11-19T19:48:09Z",
      "file": "client/src/templates/Challenges/exam-download/exam-token-controls.tsx"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-0367c2ddb152f5ede1575cbc1d92134c35de2957-client/src/templates/Challenges/exam-download/show.tsx",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import React, { useEffect, useState } from 'react';\nimport { graphql } from 'gatsby';\nimport Helmet from 'react-helmet';\nimport {\n  Button,\n  Callout,\n  Dropdown,\n  MenuItem,\n  Spacer,\n  Container,\n  Row,\n  Col\n} from '@freecodecamp/ui';\nimport { isEmpty } from 'lodash';\nimport { useTranslation, withTranslation } from 'react-i18next';\nimport { createSelector } from 'reselect';\nimport { connect } from 'react-redux';\n\nimport LearnLayout from '../../../components/layouts/learn';\nimport ChallengeTitle from '../components/challenge-title';\nimport useDetectOS from '../utils/use-detect-os';\nimport { ChallengeNode, CompletedChallenge } from '../../../redux/prop-types';\nimport {\n  completedChallengesSelector,\n  isSignedInSelector\n} from '../../../redux/selectors';\nimport { examAttempts } from '../../../utils/ajax';\nimport MissingPrerequisites from '../exam/components/missing-prerequisites';\nimport { isChallengeCompletedSelector } from '../redux/selectors';\nimport { Attempts } from './attempts';\nimport ExamTokenControls from './exam-token-controls';\n\nimport './show.css';\n\ninterface GitProps {\n  tag_name: string;\n  assets: {\n    browser_download_url: string;\n  }[];\n}\n\nconst mapStateToProps = createSelector(\n  completedChallengesSelector,\n  isChallengeCompletedSelector,\n  isSignedInSelector,\n  (\n    completedChallenges: CompletedChallenge[],\n    isChallengeCompleted: boolean,\n    isSignedIn: boolean\n  ) => ({\n    completedChallenges,\n    isChallengeCompleted,\n    isSignedIn\n  })\n);\n\ninterface ShowExamDownloadProps {\n  data: {\n    challengeNode: ChallengeNode;\n    allChallengeNode: { nodes: ChallengeNode[] };\n  };\n  completedChallenges: CompletedChallenge[];\n  isChallengeCompleted: boolean;\n  isSignedIn: boolean;\n}\n\nfunction ShowExamDownload({\n  data: {\n    challengeNode: {\n      challenge: { id, superBlock: examSuperBlock, title, translationPending }\n    },\n    allChallengeNode: { nodes }\n  },\n  completedChallenges,\n  isChallengeCompleted,\n  isSignedIn\n}: ShowExamDownloadProps): JSX.Element {\n  const [latestVersion, setLatestVersion] = useState<string | null>(null);\n\n  const [downloadLink, setDownloadLink] = useState<string | undefined>('');\n  const [downloadLinks, setDownloadLinks] = useState<string[]>([]);\n\n  const getExamsQuery = examAttempts.useGetExamsQuery(undefined, {\n    skip: !isSignedIn\n  });\n  const examIdsQuery = examAttempts.useGetExamIdsByChallengeIdQuery(id, {\n    skip: !isSignedIn\n  });\n\n  const os = useDetectOS();\n\n  const { t } = useTranslation();\n\n  function handleDownloadLink(downloadLinks: string[]) {\n    const win = downloadLinks.find(link => link.match(/\\.exe/));\n    const macARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/\\.dmg/)\n    );\n    const macX64 = downloadLinks.find(\n      link => link.match(/x64/) && link.match(/\\.dmg/)\n    );\n\n    const linuxARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/tar\\.gz/)\n    );\n\n    const linuxX64 = downloadLinks.find(\n      link => link.match(/amd64/) && link.match(/AppImage/)\n    );\n\n    if (os.os === 'WIN') {\n      if (isEmpty(win)) return '';\n\n      return win;\n    }\n\n    if (os.os === 'MAC') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(macARM)) return '';\n\n        return macARM;\n      } else {\n        if (isEmpty(macX64)) return '';\n\n        return macX64;\n      }\n    }\n\n    if (os.os === 'LINUX') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(linuxARM)) return '';\n\n        return linuxARM;\n      } else {\n        if (isEmpty(linuxX64)) return '';\n\n        return linuxX64;\n      }\n    }\n\n    return '';\n  }\n\n  useEffect(() => {\n    async function checkLatestVersion() {\n      try {\n        const response = await fetch(\n          'https://api.github.com/repos/freeCodeCamp/exam-env/releases/latest'\n        );\n        if (response.ok) {\n          const data = (await response.json()) as GitProps;\n          const { tag_name, assets } = data;\n          setLatestVersion(tag_name);\n          const urls = assets.map(link => link.browser_download_url);\n          setDownloadLink(handleDownloadLink(urls));\n          setDownloadLinks(urls);\n        }\n      } catch {\n        setLatestVersion('...');\n      }\n    }\n\n    void checkLatestVersion();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [os]);\n\n  const examId = examIdsQuery.data?.at(0)?.examId;\n  const exam = getExamsQuery.data?.find(examItem => examItem.id === examId);\n  const unmetPrerequisites = exam?.prerequisites?.filter(\n    prereq => !completedChallenges.some(challenge => challenge.id === prereq)\n  );\n  const challenges = nodes.filter(\n    ({ challenge }) =>\n      unmetPrerequisites?.includes(challenge.id) &&\n      challenge.superBlock === examSuperBlock\n  );\n  const missingPrerequisites = challenges.map(({ challenge }) => {\n    return {\n      id: challenge.id,\n      title: challenge.title,\n      slug: challenge.fields?.slug || ''\n    };\n  });\n\n  return (\n    <LearnLayout>\n      <Helmet>\n        <title>\n          {title ? `${title} | freeCodeCamp.org` : 'freeCodeCamp.org'}\n        </title>\n      </Helmet>\n      <Container>\n        <Row>\n          <Col md={8} mdOffset={2} sm={10} smOffset={1} xs={12}>\n            <Spacer size='m' />\n            <ChallengeTitle\n              isCompleted={isChallengeCompleted}\n              translationPending={translationPending}\n            >\n              {title}\n            </ChallengeTitle>\n            <Spacer size='m' />\n            {missingPrerequisites.length > 0 ? (\n              <MissingPrerequisites\n                missingPrerequisites={missingPrerequisites}\n              />\n            ) : (\n              <Callout className='exam-qualified' variant='info'>\n                <p>{t('learn.exam.qualified')}</p>\n              </Callout>\n            )}\n            <h2>{t('exam.download-header')}</h2>\n            <p>{t('exam.explanation')}</p>\n            <Spacer size='l' />\n            {isSignedIn && (\n              <>\n                <h2>{t('exam.attempts')}</h2>\n                <Attempts examChallengeId={id} />\n                <Spacer size='l' />\n                <ExamTokenControls />\n              </>\n            )}\n            <p>\n              {t('exam.version', {\n                version: latestVersion || '...'\n              })}\n            </p>\n            {/* TODO: confirm this works on MacOS */}\n            <Button href={'exam-environment://'}>\n              {t('exam.open-exam-application')}\n            </Button>\n            <Spacer size='s' />\n            <div className='exam-download-buttons'>\n              {downloadLink ? (\n                <Button href={downloadLink} download={downloadLink}>\n                  {t('buttons.download-latest-version')}\n                </Button>\n              ) : (\n                <strong>{t('exam.unable-to-detect-os')}</strong>\n              )}\n            </div>\n            <Spacer size='xs' />\n            <Dropdown dropup>\n              <Dropdown.Toggle>{t('exam.download-details')}</Dropdown.Toggle>\n              <Dropdown.Menu>\n                {downloadLinks\n                  .filter(link => !link.match(/\\.sig|\\.json/))\n                  .map((link, index) => {\n                    const urlEnd = link.split('/').pop() ?? '';\n                    return (\n                      <MenuItem\n                        href={link}\n                        download={link}\n                        key={index}\n                        variant='primary'\n                      >\n                        {urlEnd}\n                      </MenuItem>\n                    );\n                  })}\n              </Dropdown.Menu>\n            </Dropdown>\n            <Spacer size='l' />\n            <strong>{t('exam.download-trouble')}</strong>{' '}\n            <a href='mailto: support@freecodecamp.org'>\n              support@freecodecamp.org\n            </a>\n            <Spacer size='l' />\n          </Col>\n        </Row>\n      </Container>\n    </LearnLayout>\n  );\n}\n\nexport default connect(mapStateToProps)(withTranslation()(ShowExamDownload));\n\n// GraphQL\nexport const query = graphql`\n  query ExamEnvironmentExam($id: String!) {\n    challengeNode(id: { eq: $id }) {\n      challenge {\n        id\n        superBlock\n        title\n        translationPending\n      }\n    }\n    allChallengeNode {\n      nodes {\n        challenge {\n          id\n          title\n          fields {\n            slug\n          }\n          superBlock\n        }\n      }\n    }\n  }\n`;\n",
    "afterCode": "import React, { useEffect, useState } from 'react';\nimport { graphql } from 'gatsby';\nimport Helmet from 'react-helmet';\nimport {\n  Button,\n  Callout,\n  Dropdown,\n  MenuItem,\n  Spacer,\n  Container,\n  Row,\n  Col\n} from '@freecodecamp/ui';\nimport { isEmpty } from 'lodash';\nimport { useTranslation, withTranslation } from 'react-i18next';\nimport { createSelector } from 'reselect';\nimport { connect } from 'react-redux';\n\nimport LearnLayout from '../../../components/layouts/learn';\nimport ChallengeTitle from '../components/challenge-title';\nimport useDetectOS from '../utils/use-detect-os';\nimport {\n  ChallengeNode,\n  CompletedChallenge,\n  User\n} from '../../../redux/prop-types';\nimport {\n  completedChallengesSelector,\n  isSignedInSelector,\n  userSelector\n} from '../../../redux/selectors';\nimport { examAttempts } from '../../../utils/ajax';\nimport MissingPrerequisites from '../exam/components/missing-prerequisites';\nimport { isChallengeCompletedSelector } from '../redux/selectors';\nimport { Attempts } from './attempts';\nimport ExamTokenControls from './exam-token-controls';\n\nimport './show.css';\n\ninterface GitProps {\n  tag_name: string;\n  assets: {\n    browser_download_url: string;\n  }[];\n}\n\nconst mapStateToProps = createSelector(\n  completedChallengesSelector,\n  isChallengeCompletedSelector,\n  isSignedInSelector,\n  userSelector,\n  (\n    completedChallenges: CompletedChallenge[],\n    isChallengeCompleted: boolean,\n    isSignedIn: boolean,\n    user: User | null\n  ) => ({\n    completedChallenges,\n    isChallengeCompleted,\n    isSignedIn,\n    user\n  })\n);\n\ninterface ShowExamDownloadProps {\n  data: {\n    challengeNode: ChallengeNode;\n    allChallengeNode: { nodes: ChallengeNode[] };\n  };\n  completedChallenges: CompletedChallenge[];\n  isChallengeCompleted: boolean;\n  isSignedIn: boolean;\n  user: User | null;\n}\n\nfunction ShowExamDownload({\n  data: {\n    challengeNode: {\n      challenge: { id, superBlock: examSuperBlock, title, translationPending }\n    },\n    allChallengeNode: { nodes }\n  },\n  completedChallenges,\n  isChallengeCompleted,\n  isSignedIn,\n  user\n}: ShowExamDownloadProps): JSX.Element {\n  const [latestVersion, setLatestVersion] = useState<string | null>(null);\n\n  const [downloadLink, setDownloadLink] = useState<string | undefined>('');\n  const [downloadLinks, setDownloadLinks] = useState<string[]>([]);\n\n  const getExamsQuery = examAttempts.useGetExamsQuery(undefined, {\n    skip: !isSignedIn\n  });\n  const examIdsQuery = examAttempts.useGetExamIdsByChallengeIdQuery(id, {\n    skip: !isSignedIn\n  });\n\n  const os = useDetectOS();\n\n  const { t } = useTranslation();\n\n  function handleDownloadLink(downloadLinks: string[]) {\n    const win = downloadLinks.find(link => link.match(/\\.exe/));\n    const macARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/\\.dmg/)\n    );\n    const macX64 = downloadLinks.find(\n      link => link.match(/x64/) && link.match(/\\.dmg/)\n    );\n\n    const linuxARM = downloadLinks.find(\n      link => link.match(/aarch64/) && link.match(/tar\\.gz/)\n    );\n\n    const linuxX64 = downloadLinks.find(\n      link => link.match(/amd64/) && link.match(/AppImage/)\n    );\n\n    if (os.os === 'WIN') {\n      if (isEmpty(win)) return '';\n\n      return win;\n    }\n\n    if (os.os === 'MAC') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(macARM)) return '';\n\n        return macARM;\n      } else {\n        if (isEmpty(macX64)) return '';\n\n        return macX64;\n      }\n    }\n\n    if (os.os === 'LINUX') {\n      if (os.architecture.toLowerCase() === 'arm') {\n        if (isEmpty(linuxARM)) return '';\n\n        return linuxARM;\n      } else {\n        if (isEmpty(linuxX64)) return '';\n\n        return linuxX64;\n      }\n    }\n\n    return '';\n  }\n\n  useEffect(() => {\n    async function checkLatestVersion() {\n      try {\n        const response = await fetch(\n          'https://api.github.com/repos/freeCodeCamp/exam-env/releases/latest'\n        );\n        if (response.ok) {\n          const data = (await response.json()) as GitProps;\n          const { tag_name, assets } = data;\n          setLatestVersion(tag_name);\n          const urls = assets.map(link => link.browser_download_url);\n          setDownloadLink(handleDownloadLink(urls));\n          setDownloadLinks(urls);\n        }\n      } catch {\n        setLatestVersion('...');\n      }\n    }\n\n    void checkLatestVersion();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [os]);\n\n  const examId = examIdsQuery.data?.at(0)?.examId;\n  const exam = getExamsQuery.data?.find(examItem => examItem.id === examId);\n  const unmetPrerequisites = exam?.prerequisites?.filter(\n    prereq => !completedChallenges.some(challenge => challenge.id === prereq)\n  );\n  const challenges = nodes.filter(\n    ({ challenge }) =>\n      unmetPrerequisites?.includes(challenge.id) &&\n      challenge.superBlock === examSuperBlock\n  );\n  const missingPrerequisites = challenges.map(({ challenge }) => {\n    return {\n      id: challenge.id,\n      title: challenge.title,\n      slug: challenge.fields?.slug || ''\n    };\n  });\n\n  return (\n    <LearnLayout>\n      <Helmet>\n        <title>\n          {title ? `${title} | freeCodeCamp.org` : 'freeCodeCamp.org'}\n        </title>\n      </Helmet>\n      <Container>\n        <Row>\n          <Col md={8} mdOffset={2} sm={10} smOffset={1} xs={12}>\n            <Spacer size='m' />\n            <ChallengeTitle\n              isCompleted={isChallengeCompleted}\n              translationPending={translationPending}\n            >\n              {title}\n            </ChallengeTitle>\n            <Spacer size='m' />\n            {missingPrerequisites.length > 0 ? (\n              <MissingPrerequisites\n                missingPrerequisites={missingPrerequisites}\n              />\n            ) : (\n              <Callout className='exam-qualified' variant='info'>\n                <p>{t('learn.exam.qualified')}</p>\n              </Callout>\n            )}\n            <h2>{t('exam.download-header')}</h2>\n            <p>{t('exam.explanation')}</p>\n            <Spacer size='l' />\n            {isSignedIn && (\n              <>\n                <h2>{t('exam.attempts')}</h2>\n                <Attempts examChallengeId={id} />\n                <Spacer size='l' />\n                <ExamTokenControls email={user!.email} />\n              </>\n            )}\n            <p>\n              {t('exam.version', {\n                version: latestVersion || '...'\n              })}\n            </p>\n            {/* TODO: confirm this works on MacOS */}\n            <Button href={'exam-environment://'}>\n              {t('exam.open-exam-application')}\n            </Button>\n            <Spacer size='s' />\n            <div className='exam-download-buttons'>\n              {downloadLink ? (\n                <Button href={downloadLink} download={downloadLink}>\n                  {t('buttons.download-latest-version')}\n                </Button>\n              ) : (\n                <strong>{t('exam.unable-to-detect-os')}</strong>\n              )}\n            </div>\n            <Spacer size='xs' />\n            <Dropdown dropup>\n              <Dropdown.Toggle>{t('exam.download-details')}</Dropdown.Toggle>\n              <Dropdown.Menu>\n                {downloadLinks\n                  .filter(link => !link.match(/\\.sig|\\.json/))\n                  .map((link, index) => {\n                    const urlEnd = link.split('/').pop() ?? '';\n                    return (\n                      <MenuItem\n                        href={link}\n                        download={link}\n                        key={index}\n                        variant='primary'\n                      >\n                        {urlEnd}\n                      </MenuItem>\n                    );\n                  })}\n              </Dropdown.Menu>\n            </Dropdown>\n            <Spacer size='l' />\n            <strong>{t('exam.download-trouble')}</strong>{' '}\n            <a href='mailto: support@freecodecamp.org'>\n              support@freecodecamp.org\n            </a>\n            <Spacer size='l' />\n          </Col>\n        </Row>\n      </Container>\n    </LearnLayout>\n  );\n}\n\nexport default connect(mapStateToProps)(withTranslation()(ShowExamDownload));\n\n// GraphQL\nexport const query = graphql`\n  query ExamEnvironmentExam($id: String!) {\n    challengeNode(id: { eq: $id }) {\n      challenge {\n        id\n        superBlock\n        title\n        translationPending\n      }\n    }\n    allChallengeNode {\n      nodes {\n        challenge {\n          id\n          title\n          fields {\n            slug\n          }\n          superBlock\n        }\n      }\n    }\n  }\n`;\n",
    "linesChanged": 22,
    "complexity": 8622,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "0367c2ddb152f5ede1575cbc1d92134c35de2957",
      "author": "Shaun Hamilton",
      "date": "2025-11-19T19:48:09Z",
      "file": "client/src/templates/Challenges/exam-download/show.tsx"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-971134863d29031bc01b8218c2000416b4060547-client/src/utils/ajax.ts",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import cookies from 'browser-cookies';\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nimport envData from '../../config/env.json';\nimport type {\n  ChallengeFile,\n  ChallengeFiles,\n  CompletedChallenge,\n  ExamTokenResponse,\n  GenerateExamResponseWithData,\n  SavedChallenge,\n  SavedChallengeFile,\n  SurveyResults,\n  User\n} from '../redux/prop-types';\nimport { DonationDuration } from '../../../shared-dist/config/donation-settings';\n\nconst { apiLocation } = envData;\n\nconst base = apiLocation;\n\nconst defaultOptions: RequestInit = {\n  credentials: 'include'\n};\n\n// csrf_token is passed to the client as a cookie. The client must send\n// this back as a header.\nfunction getCSRFToken() {\n  const token =\n    typeof window !== 'undefined' ? cookies.get('csrf_token') : null;\n  return token ?? '';\n}\n\nexport interface ResponseWithData<T> {\n  response: Response;\n  data: T;\n}\n\n// TODO: Might want to handle flash messages as close to the request as possible\n// to make use of the Response object (message, status, etc)\nasync function get<T>(\n  path: string,\n  signal?: AbortSignal\n): Promise<ResponseWithData<T>> {\n  const response = await fetch(`${base}${path}`, {\n    ...defaultOptions,\n    headers: { 'CSRF-Token': getCSRFToken() },\n    signal\n  });\n\n  return combineDataWithResponse(response);\n}\n\nasync function combineDataWithResponse<T>(response: Response) {\n  const data = (await response.json()) as T;\n  return { response, data };\n}\n\nexport function post<T = void>(\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  return request('POST', path, body);\n}\n\nfunction put<T = void>(\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  return request('PUT', path, body);\n}\n\nfunction deleteRequest<T = void>(\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  return request('DELETE', path, body);\n}\n\nasync function request<T>(\n  method: 'POST' | 'PUT' | 'DELETE',\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  const options: RequestInit = {\n    ...defaultOptions,\n    method,\n    headers: {\n      'CSRF-Token': getCSRFToken(),\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(body)\n  };\n\n  const response = await fetch(`${base}${path}`, options);\n  return combineDataWithResponse(response);\n}\n\n/** GET **/\n\ntype CompleteChallengeFromApi = {\n  files: Array<Omit<ChallengeFile, 'fileKey'> & { key: string }>;\n} & Omit<CompletedChallenge, 'challengeFiles'>;\n\ntype SavedChallengeFromApi = {\n  files: Array<Omit<SavedChallengeFile, 'fileKey'> & { key: string }>;\n} & Omit<SavedChallenge, 'challengeFiles'>;\n\ntype ApiUser = Omit<User, 'completedChallenges' & 'savedChallenges'> & {\n  completedChallenges?: CompleteChallengeFromApi[];\n  savedChallenges?: SavedChallengeFromApi[];\n};\n\ntype ApiUserResponse = {\n  user: {\n    [username: string]: ApiUser;\n  };\n  result?: string;\n};\n\nfunction parseApiResponseToClientUser(data: ApiUserResponse): User | null {\n  const userData = data.user?.[data?.result ?? ''];\n  let completedChallenges: CompletedChallenge[] = [];\n  let savedChallenges: SavedChallenge[] = [];\n  if (userData) {\n    completedChallenges = mapFilesToChallengeFiles(\n      userData.completedChallenges\n    );\n    savedChallenges = mapFilesToChallengeFiles(userData.savedChallenges);\n  }\n  return data.result\n    ? { ...userData, completedChallenges, savedChallenges }\n    : null;\n}\n\n// TODO: this at least needs a few aliases so it's human readable\nexport function mapFilesToChallengeFiles<File, Rest>(\n  fileContainer: ({ files: (File & { key: string })[] } & Rest)[] = []\n) {\n  return fileContainer.map(({ files, ...rest }) => ({\n    ...rest,\n    challengeFiles: mapKeyToFileKey(files)\n  }));\n}\n\nfunction mapKeyToFileKey<K>(\n  files: (K & { key: string })[]\n): (Omit<K, 'key'> & { fileKey: string })[] {\n  return files.map(({ key, ...rest }) => ({ ...rest, fileKey: key }));\n}\n\nexport function getSessionUser(\n  signal?: AbortSignal\n): Promise<ResponseWithData<User | null>> {\n  const responseWithData: Promise<ResponseWithData<ApiUserResponse>> = get(\n    '/user/get-session-user',\n    signal\n  );\n  // TODO: Once DB is migrated, no longer need to parse `files` -> `challengeFiles` etc.\n  return responseWithData.then(({ response, data }) => {\n    const user = parseApiResponseToClientUser(data);\n    return {\n      response,\n      data: user\n    };\n  });\n}\n\ntype UserProfileResponse = {\n  entities: Omit<ApiUserResponse, 'result'>;\n  result: string | undefined;\n};\nexport function getUserProfile(\n  username: string\n): Promise<ResponseWithData<User | null>> {\n  const responseWithData = get<UserProfileResponse>(\n    `/users/get-public-profile?username=${username}`\n  );\n  return responseWithData.then(({ response, data }) => {\n    const user = parseApiResponseToClientUser({\n      user: data.entities?.user ?? {},\n      result: data.result\n    });\n    return {\n      response,\n      data: user\n    };\n  });\n}\n\ninterface Cert {\n  certTitle: string;\n  username: string;\n  date: Date;\n  completionTime: string;\n}\nexport function getShowCert(\n  username: string,\n  certSlug: string\n): Promise<ResponseWithData<Cert>> {\n  return get(`/certificate/showCert/${username}/${certSlug}`);\n}\n\nexport function getUsernameExists(\n  username: string\n): Promise<ResponseWithData<boolean>> {\n  return get(`/users/exists?username=${username}`);\n}\n\nexport function getGenerateExam(\n  challengeId: string\n): Promise<GenerateExamResponseWithData> {\n  return get(`/exam/${challengeId}`);\n}\n\nexport interface Exam {\n  id: string;\n  config: {\n    name: string;\n  };\n}\n\nexport type Attempt = {\n  id: string;\n  examId: string;\n  // ISO 8601 string\n  startTime: string;\n  questionSets: unknown[];\n} & (\n  | {\n      result: null;\n      status: 'InProgress' | 'Expired' | 'PendingModeration' | 'Denied';\n    }\n  | {\n      status: 'Approved';\n      result: {\n        passingPercent: number;\n        score: number;\n      };\n    }\n);\n\nexport function getExams(): Promise<ResponseWithData<{ exams: Exam[] }>> {\n  return get('/user/exam-environment/exams');\n}\n\nexport function getExamAttempts(): Promise<ResponseWithData<Attempt[]>> {\n  return get('/user/exam-environment/exam/attempts');\n}\n\n/** POST **/\n\ninterface Donation {\n  email: string;\n  amount: number;\n  duration: string;\n  provider: string;\n  subscriptionId: string;\n  customerId: string;\n  startDate: Date;\n}\n// TODO: Verify if the body has and needs this Donation type. The api seems to\n// just need the body to exist, but doesn't seem to use the properties.\nexport function addDonation(body: Donation): Promise<ResponseWithData<void>> {\n  return post('/donate/add-donation', body);\n}\n\nexport function updateStripeCard() {\n  return put('/donate/update-stripe-card', {});\n}\n\nexport function postChargeStripe(\n  body: Donation\n): Promise<ResponseWithData<void>> {\n  return post('/donate/charge-stripe', body);\n}\n\nexport function postChargeStripeCard(\n  body: Donation\n): Promise<ResponseWithData<void>> {\n  return post('/donate/charge-stripe-card', body);\n}\n\nexport function generateExamToken(): Promise<\n  ResponseWithData<ExamTokenResponse>\n> {\n  return post('/user/exam-environment/token', {});\n}\n\ntype PaymentIntentResponse = Promise<\n  ResponseWithData<\n    | {\n        clientSecret?: never;\n        subscriptionId?: never;\n        error: string;\n      }\n    | {\n        clientSecret: string;\n        subscriptionId: string;\n        error?: never;\n      }\n  >\n>;\n\nexport function createStripePaymentIntent(body: {\n  email: string | undefined;\n  name: string | undefined;\n  amount: number;\n  duration: DonationDuration;\n}): PaymentIntentResponse {\n  return post('/donate/create-stripe-payment-intent', body);\n}\n\ninterface Report {\n  username: string;\n  reportDescription: string;\n}\nexport function postReportUser(body: Report): Promise<ResponseWithData<void>> {\n  return post('/user/report-user', body);\n}\n\n// Both are called without a payload in danger-zone-saga,\n// which suggests both are sent without any body\n// TODO: Convert to DELETE\nexport function postDeleteAccount(): Promise<ResponseWithData<void>> {\n  return post('/account/delete', {});\n}\n\nexport function postResetProgress(): Promise<ResponseWithData<void>> {\n  return post('/account/reset-progress', {});\n}\n\nexport function postUserToken(): Promise<ResponseWithData<void>> {\n  return post('/user/user-token', {});\n}\n\nexport function postMsUsername(body: {\n  msTranscriptUrl: string;\n}): Promise<ResponseWithData<void>> {\n  return post('/user/ms-username', body);\n}\n\nexport function postSaveChallenge(body: {\n  id: string;\n  files: ChallengeFiles;\n}): Promise<ResponseWithData<void>> {\n  return post('/encoded/save-challenge', body);\n}\n\nexport function postSubmitSurvey(body: {\n  surveyResults: SurveyResults;\n}): Promise<ResponseWithData<void>> {\n  return post('/user/submit-survey', body);\n}\n\n/** PUT **/\n\ninterface MyAbout {\n  name: string;\n  location: string;\n  about: string;\n  picture: string;\n}\nexport function putUpdateMyAbout(\n  values: MyAbout\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-about', { ...values });\n}\n\nexport function putUpdateMyUsername(\n  username: string\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-username', { username });\n}\n\nexport function putUpdateMyProfileUI(\n  profileUI: User['profileUI']\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-profileui', { profileUI });\n}\n\nexport function putUpdateMySocials(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-socials', update);\n}\n\nexport function putUpdateMyKeyboardShortcuts(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-keyboard-shortcuts', update);\n}\n\nexport function putUpdateMyHonesty(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-honesty', update);\n}\n\nexport function putUpdateMyQuincyEmail(update: {\n  sendQuincyEmail: boolean;\n}): Promise<ResponseWithData<void>> {\n  return put('/update-my-quincy-email', update);\n}\n\nexport function putUpdateMyPortfolio(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-portfolio', update);\n}\n\nexport function putUserUpdateEmail(\n  email: string\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-email', { email });\n}\n\nexport function putVerifyCert(\n  certSlug: string\n): Promise<ResponseWithData<void>> {\n  return put('/certificate/verify', { certSlug });\n}\n\n/** DELETE **/\nexport function deleteUserToken(): Promise<ResponseWithData<void>> {\n  return deleteRequest('/user/user-token', {});\n}\n\nexport function deleteMsUsername(): Promise<ResponseWithData<void>> {\n  return deleteRequest('/user/ms-username', {});\n}\n\n/** RTK */\n\nexport interface ExamEnvironmentChallenge {\n  id: string;\n  examId: string;\n  challengeId: string;\n}\n\nexport type GetExamsResponse = Array<{\n  id: string;\n  config: {\n    name: string;\n    note: string;\n    totalTimeInS: number;\n    retakeTimeInS: number;\n    passingPercent: number;\n  };\n  canTake: boolean;\n  prerequisites: string[];\n}>;\n\nexport const examAttempts = createApi({\n  reducerPath: 'exam-attempts',\n  baseQuery: fetchBaseQuery({\n    baseUrl: apiLocation,\n    headers: {\n      'CSRF-Token': getCSRFToken()\n    },\n    credentials: 'include'\n  }),\n  endpoints: build => ({\n    getExamAttemptsByExamId: build.mutation<Attempt[], string>({\n      query: examId => `/user/exam-environment/exams/${examId}/attempts`\n    }),\n    getExamIdsByChallengeId: build.query<ExamEnvironmentChallenge[], string>({\n      query: challengeId =>\n        `/exam-environment/exam-challenge?challengeId=${challengeId}`\n    }),\n    getExams: build.query<GetExamsResponse, void>({\n      query: () => '/user/exam-environment/exams'\n    })\n  })\n});\n\nexport const examEnvironmentAuthorizationTokenApi = createApi({\n  reducerPath: 'exam-environment-authorization-token',\n  baseQuery: fetchBaseQuery({\n    baseUrl: apiLocation,\n    headers: {\n      'CSRF-Token': getCSRFToken()\n    },\n    credentials: 'include'\n  }),\n  endpoints: build => ({\n    postGenerateExamEnvironmentAuthorizationToken: build.mutation<\n      ExamTokenResponse,\n      void\n    >({\n      query: () => ({\n        url: `/user/exam-environment/token`,\n        method: 'POST'\n      })\n    }),\n    getExamEnvironmentAuthorizationToken: build.query<ExamTokenResponse, void>({\n      query: () => ({\n        url: `/user/exam-environment/token`,\n        method: 'GET'\n      })\n    })\n  })\n});\n",
    "afterCode": "import cookies from 'browser-cookies';\nimport { createApi, fetchBaseQuery, retry } from '@reduxjs/toolkit/query/react';\n\nimport envData from '../../config/env.json';\nimport type {\n  ChallengeFile,\n  ChallengeFiles,\n  CompletedChallenge,\n  ExamTokenResponse,\n  GenerateExamResponseWithData,\n  SavedChallenge,\n  SavedChallengeFile,\n  SurveyResults,\n  User\n} from '../redux/prop-types';\nimport { DonationDuration } from '../../../shared-dist/config/donation-settings';\n\nconst { apiLocation } = envData;\n\nconst base = apiLocation;\n\nconst defaultOptions: RequestInit = {\n  credentials: 'include'\n};\n\n// csrf_token is passed to the client as a cookie. The client must send\n// this back as a header.\nfunction getCSRFToken() {\n  const token =\n    typeof window !== 'undefined' ? cookies.get('csrf_token') : null;\n  return token ?? '';\n}\n\nexport interface ResponseWithData<T> {\n  response: Response;\n  data: T;\n}\n\n// TODO: Might want to handle flash messages as close to the request as possible\n// to make use of the Response object (message, status, etc)\nasync function get<T>(\n  path: string,\n  signal?: AbortSignal\n): Promise<ResponseWithData<T>> {\n  const response = await fetch(`${base}${path}`, {\n    ...defaultOptions,\n    headers: { 'CSRF-Token': getCSRFToken() },\n    signal\n  });\n\n  return combineDataWithResponse(response);\n}\n\nasync function combineDataWithResponse<T>(response: Response) {\n  const data = (await response.json()) as T;\n  return { response, data };\n}\n\nexport function post<T = void>(\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  return request('POST', path, body);\n}\n\nfunction put<T = void>(\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  return request('PUT', path, body);\n}\n\nfunction deleteRequest<T = void>(\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  return request('DELETE', path, body);\n}\n\nasync function request<T>(\n  method: 'POST' | 'PUT' | 'DELETE',\n  path: string,\n  body: unknown\n): Promise<ResponseWithData<T>> {\n  const options: RequestInit = {\n    ...defaultOptions,\n    method,\n    headers: {\n      'CSRF-Token': getCSRFToken(),\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(body)\n  };\n\n  const response = await fetch(`${base}${path}`, options);\n  return combineDataWithResponse(response);\n}\n\n/** GET **/\n\ntype CompleteChallengeFromApi = {\n  files: Array<Omit<ChallengeFile, 'fileKey'> & { key: string }>;\n} & Omit<CompletedChallenge, 'challengeFiles'>;\n\ntype SavedChallengeFromApi = {\n  files: Array<Omit<SavedChallengeFile, 'fileKey'> & { key: string }>;\n} & Omit<SavedChallenge, 'challengeFiles'>;\n\ntype ApiUser = Omit<User, 'completedChallenges' & 'savedChallenges'> & {\n  completedChallenges?: CompleteChallengeFromApi[];\n  savedChallenges?: SavedChallengeFromApi[];\n};\n\ntype ApiUserResponse = {\n  user: {\n    [username: string]: ApiUser;\n  };\n  result?: string;\n};\n\nfunction parseApiResponseToClientUser(data: ApiUserResponse): User | null {\n  const userData = data.user?.[data?.result ?? ''];\n  let completedChallenges: CompletedChallenge[] = [];\n  let savedChallenges: SavedChallenge[] = [];\n  if (userData) {\n    completedChallenges = mapFilesToChallengeFiles(\n      userData.completedChallenges\n    );\n    savedChallenges = mapFilesToChallengeFiles(userData.savedChallenges);\n  }\n  return data.result\n    ? { ...userData, completedChallenges, savedChallenges }\n    : null;\n}\n\n// TODO: this at least needs a few aliases so it's human readable\nexport function mapFilesToChallengeFiles<File, Rest>(\n  fileContainer: ({ files: (File & { key: string })[] } & Rest)[] = []\n) {\n  return fileContainer.map(({ files, ...rest }) => ({\n    ...rest,\n    challengeFiles: mapKeyToFileKey(files)\n  }));\n}\n\nfunction mapKeyToFileKey<K>(\n  files: (K & { key: string })[]\n): (Omit<K, 'key'> & { fileKey: string })[] {\n  return files.map(({ key, ...rest }) => ({ ...rest, fileKey: key }));\n}\n\nexport function getSessionUser(\n  signal?: AbortSignal\n): Promise<ResponseWithData<User | null>> {\n  const responseWithData: Promise<ResponseWithData<ApiUserResponse>> = get(\n    '/user/get-session-user',\n    signal\n  );\n  // TODO: Once DB is migrated, no longer need to parse `files` -> `challengeFiles` etc.\n  return responseWithData.then(({ response, data }) => {\n    const user = parseApiResponseToClientUser(data);\n    return {\n      response,\n      data: user\n    };\n  });\n}\n\ntype UserProfileResponse = {\n  entities: Omit<ApiUserResponse, 'result'>;\n  result: string | undefined;\n};\nexport function getUserProfile(\n  username: string\n): Promise<ResponseWithData<User | null>> {\n  const responseWithData = get<UserProfileResponse>(\n    `/users/get-public-profile?username=${username}`\n  );\n  return responseWithData.then(({ response, data }) => {\n    const user = parseApiResponseToClientUser({\n      user: data.entities?.user ?? {},\n      result: data.result\n    });\n    return {\n      response,\n      data: user\n    };\n  });\n}\n\ninterface Cert {\n  certTitle: string;\n  username: string;\n  date: Date;\n  completionTime: string;\n}\nexport function getShowCert(\n  username: string,\n  certSlug: string\n): Promise<ResponseWithData<Cert>> {\n  return get(`/certificate/showCert/${username}/${certSlug}`);\n}\n\nexport function getUsernameExists(\n  username: string\n): Promise<ResponseWithData<boolean>> {\n  return get(`/users/exists?username=${username}`);\n}\n\nexport function getGenerateExam(\n  challengeId: string\n): Promise<GenerateExamResponseWithData> {\n  return get(`/exam/${challengeId}`);\n}\n\nexport interface Exam {\n  id: string;\n  config: {\n    name: string;\n  };\n}\n\nexport type Attempt = {\n  id: string;\n  examId: string;\n  // ISO 8601 string\n  startTime: string;\n  questionSets: unknown[];\n} & (\n  | {\n      result: null;\n      status: 'InProgress' | 'Expired' | 'PendingModeration' | 'Denied';\n    }\n  | {\n      status: 'Approved';\n      result: {\n        passingPercent: number;\n        score: number;\n      };\n    }\n);\n\nexport function getExams(): Promise<ResponseWithData<{ exams: Exam[] }>> {\n  return get('/user/exam-environment/exams');\n}\n\nexport function getExamAttempts(): Promise<ResponseWithData<Attempt[]>> {\n  return get('/user/exam-environment/exam/attempts');\n}\n\n/** POST **/\n\ninterface Donation {\n  email: string;\n  amount: number;\n  duration: string;\n  provider: string;\n  subscriptionId: string;\n  customerId: string;\n  startDate: Date;\n}\n// TODO: Verify if the body has and needs this Donation type. The api seems to\n// just need the body to exist, but doesn't seem to use the properties.\nexport function addDonation(body: Donation): Promise<ResponseWithData<void>> {\n  return post('/donate/add-donation', body);\n}\n\nexport function updateStripeCard() {\n  return put('/donate/update-stripe-card', {});\n}\n\nexport function postChargeStripe(\n  body: Donation\n): Promise<ResponseWithData<void>> {\n  return post('/donate/charge-stripe', body);\n}\n\nexport function postChargeStripeCard(\n  body: Donation\n): Promise<ResponseWithData<void>> {\n  return post('/donate/charge-stripe-card', body);\n}\n\nexport function generateExamToken(): Promise<\n  ResponseWithData<ExamTokenResponse>\n> {\n  return post('/user/exam-environment/token', {});\n}\n\ntype PaymentIntentResponse = Promise<\n  ResponseWithData<\n    | {\n        clientSecret?: never;\n        subscriptionId?: never;\n        error: string;\n      }\n    | {\n        clientSecret: string;\n        subscriptionId: string;\n        error?: never;\n      }\n  >\n>;\n\nexport function createStripePaymentIntent(body: {\n  email: string | undefined;\n  name: string | undefined;\n  amount: number;\n  duration: DonationDuration;\n}): PaymentIntentResponse {\n  return post('/donate/create-stripe-payment-intent', body);\n}\n\ninterface Report {\n  username: string;\n  reportDescription: string;\n}\nexport function postReportUser(body: Report): Promise<ResponseWithData<void>> {\n  return post('/user/report-user', body);\n}\n\n// Both are called without a payload in danger-zone-saga,\n// which suggests both are sent without any body\n// TODO: Convert to DELETE\nexport function postDeleteAccount(): Promise<ResponseWithData<void>> {\n  return post('/account/delete', {});\n}\n\nexport function postResetProgress(): Promise<ResponseWithData<void>> {\n  return post('/account/reset-progress', {});\n}\n\nexport function postUserToken(): Promise<ResponseWithData<void>> {\n  return post('/user/user-token', {});\n}\n\nexport function postMsUsername(body: {\n  msTranscriptUrl: string;\n}): Promise<ResponseWithData<void>> {\n  return post('/user/ms-username', body);\n}\n\nexport function postSaveChallenge(body: {\n  id: string;\n  files: ChallengeFiles;\n}): Promise<ResponseWithData<void>> {\n  return post('/encoded/save-challenge', body);\n}\n\nexport function postSubmitSurvey(body: {\n  surveyResults: SurveyResults;\n}): Promise<ResponseWithData<void>> {\n  return post('/user/submit-survey', body);\n}\n\n/** PUT **/\n\ninterface MyAbout {\n  name: string;\n  location: string;\n  about: string;\n  picture: string;\n}\nexport function putUpdateMyAbout(\n  values: MyAbout\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-about', { ...values });\n}\n\nexport function putUpdateMyUsername(\n  username: string\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-username', { username });\n}\n\nexport function putUpdateMyProfileUI(\n  profileUI: User['profileUI']\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-profileui', { profileUI });\n}\n\nexport function putUpdateMySocials(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-socials', update);\n}\n\nexport function putUpdateMyKeyboardShortcuts(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-keyboard-shortcuts', update);\n}\n\nexport function putUpdateMyHonesty(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-honesty', update);\n}\n\nexport function putUpdateMyQuincyEmail(update: {\n  sendQuincyEmail: boolean;\n}): Promise<ResponseWithData<void>> {\n  return put('/update-my-quincy-email', update);\n}\n\nexport function putUpdateMyPortfolio(\n  update: Record<string, string>\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-portfolio', update);\n}\n\nexport function putUserUpdateEmail(\n  email: string\n): Promise<ResponseWithData<void>> {\n  return put('/update-my-email', { email });\n}\n\nexport function putVerifyCert(\n  certSlug: string\n): Promise<ResponseWithData<void>> {\n  return put('/certificate/verify', { certSlug });\n}\n\n/** DELETE **/\nexport function deleteUserToken(): Promise<ResponseWithData<void>> {\n  return deleteRequest('/user/user-token', {});\n}\n\nexport function deleteMsUsername(): Promise<ResponseWithData<void>> {\n  return deleteRequest('/user/ms-username', {});\n}\n\n/** RTK */\n\nexport interface ExamEnvironmentChallenge {\n  id: string;\n  examId: string;\n  challengeId: string;\n}\n\nexport type GetExamsResponse = Array<{\n  id: string;\n  config: {\n    name: string;\n    note: string;\n    totalTimeInS: number;\n    retakeTimeInS: number;\n    passingPercent: number;\n  };\n  canTake: boolean;\n  prerequisites: string[];\n}>;\n\nexport const examAttempts = createApi({\n  reducerPath: 'exam-attempts',\n  baseQuery: retry(\n    fetchBaseQuery({\n      baseUrl: apiLocation,\n      prepareHeaders(headers) {\n        headers.set('CSRF-Token', getCSRFToken());\n        return headers;\n      },\n      credentials: 'include'\n    }),\n    // Retry in the case this is the initial request - csrf is not set yet, and initial returns 403\n    { maxRetries: 2 }\n  ),\n  endpoints: build => ({\n    getExamAttemptsByExamId: build.mutation<Attempt[], string>({\n      query: examId => `/user/exam-environment/exams/${examId}/attempts`\n    }),\n    getExamIdsByChallengeId: build.query<ExamEnvironmentChallenge[], string>({\n      query: challengeId =>\n        `/exam-environment/exam-challenge?challengeId=${challengeId}`\n    }),\n    getExams: build.query<GetExamsResponse, void>({\n      query: () => '/user/exam-environment/exams'\n    })\n  })\n});\n\nexport const examEnvironmentAuthorizationTokenApi = createApi({\n  reducerPath: 'exam-environment-authorization-token',\n  baseQuery: retry(\n    fetchBaseQuery({\n      baseUrl: apiLocation,\n      prepareHeaders(headers) {\n        headers.set('CSRF-Token', getCSRFToken());\n        return headers;\n      },\n      credentials: 'include'\n    }),\n    // Retry in the case this is the initial request - csrf is not set yet, and initial returns 403\n    { maxRetries: 2 }\n  ),\n  endpoints: build => ({\n    postGenerateExamEnvironmentAuthorizationToken: build.mutation<\n      ExamTokenResponse,\n      void\n    >({\n      query: () => ({\n        url: `/user/exam-environment/token`,\n        method: 'POST'\n      })\n    }),\n    getExamEnvironmentAuthorizationToken: build.query<ExamTokenResponse, void>({\n      query: () => ({\n        url: `/user/exam-environment/token`,\n        method: 'GET'\n      })\n    })\n  })\n});\n",
    "linesChanged": 40,
    "complexity": 12884,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "971134863d29031bc01b8218c2000416b4060547",
      "author": "Shaun Hamilton",
      "date": "2025-11-19T16:30:34Z",
      "file": "client/src/utils/ajax.ts"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-a2c81caae6b89a6c6430a9b6691abb495090648a-e2e/daily-coding-challenge.spec.ts",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import { test, expect } from '@playwright/test';\nimport {\n  getTodayUsCentral,\n  formatDate,\n  formatDisplayDate\n} from '../client/src/components/daily-coding-challenge/helpers';\n\nconst dateRouteRe = /.*\\/daily-coding-challenge\\/date\\/.*/;\nconst allRouteRe = /.*\\/daily-coding-challenge\\/all/;\n\nconst todayUsCentral = getTodayUsCentral();\nconst [year, month, day] = todayUsCentral.split('-').map(Number);\n\nconst todayMidnight = `${todayUsCentral}T00:00:00.000Z`;\n\nconst mockApiChallenge = {\n  id: 'test-challenge-id',\n  challengeNumber: 1,\n  title: 'Test title',\n  date: todayMidnight,\n  description: 'Test description',\n  javascript: {\n    tests: [\n      {\n        text: 'Test text',\n        testString: 'assert.strictEqual(true, true);'\n      }\n    ],\n    challengeFiles: [\n      {\n        fileKey: 'scriptjs',\n        contents: '// JavaScript seed code'\n      }\n    ]\n  },\n  python: {\n    tests: [\n      {\n        text: 'Test text',\n        testString: '({test: () => { runPython(`assert True == True`)}})'\n      }\n    ],\n    challengeFiles: [\n      {\n        fileKey: 'mainpy',\n        contents: '# Python seed code'\n      }\n    ]\n  }\n};\n\nconst mockApiAllChallenges = [\n  // today\n  {\n    // real ID from certified user so it shows completed in calendar\n    id: '6814d8e1516e86b171929de4',\n    date: todayMidnight\n  },\n  // yesterday, or tomorrow if today is the first\n  {\n    id: 'other-id',\n    date: `${formatDate({ year, month, day: day === 1 ? day + 1 : day - 1 })}T00:00:00.000Z`\n  }\n];\n\nconst mockDaysInMonth = new Date(year, month, 0).getDate();\n\ntest.describe('Daily Coding Challenges', () => {\n  test('should show not found page for invalid date', async ({ page }) => {\n    await page.goto('/learn/daily-coding-challenge/invalid-date');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should show not found page for date without challenge', async ({\n    page\n  }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 404,\n        headers: { 'Content-Type': 'application/json' },\n        json: { type: 'error', message: 'Challenge not found.' }\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/2025-01-01');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should show not found page for API error', async ({ page }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n        json: { type: 'error', message: 'Internal server error.' }\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/2025-01-01');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should show not found page for invalid challenge data', async ({\n    page\n  }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        json: { invalid: 'data structure' }\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/2025-06-27');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should load and display a daily coding challenge with a valid date, and should be able to switch between JavaScript and Python', async ({\n    page\n  }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        json: mockApiChallenge\n      });\n    });\n\n    await page.goto(`/learn/daily-coding-challenge/${todayUsCentral}`);\n\n    const leftBreadcrumb = page.getByRole('link', {\n      name: /daily coding challenge/i\n    });\n    await expect(leftBreadcrumb).toBeVisible();\n    await expect(leftBreadcrumb).toHaveAttribute(\n      'href',\n      '/learn/daily-coding-challenge/archive'\n    );\n\n    const rightBreadcrumb = page.getByRole('link', {\n      name: `${formatDisplayDate(todayUsCentral)}`\n    });\n    await expect(rightBreadcrumb).toBeVisible();\n    await expect(rightBreadcrumb).toHaveAttribute(\n      'href',\n      '/learn/daily-coding-challenge/archive'\n    );\n\n    await expect(page.getByText('Test title')).toBeVisible();\n\n    await expect(page.getByText('Test description')).toBeVisible();\n\n    // Language buttons\n    await expect(\n      page.getByRole('button', { name: /javascript/i })\n    ).toBeVisible();\n    await expect(page.getByRole('button', { name: /python/i })).toBeVisible();\n\n    // Should show JS UI by default\n\n    await expect(\n      page.getByRole('button', { name: /script.js/i })\n    ).toBeVisible();\n    await expect(\n      page.getByRole('button', { name: /main.py/i })\n    ).not.toBeVisible();\n    await expect(page.getByRole('button', { name: /console/i })).toBeVisible();\n    await expect(page.getByTestId('preview-pane-button')).not.toBeVisible();\n    await expect(page.locator(\"div[role='code'].monaco-editor\")).toContainText(\n      '// JavaScript seed code'\n    );\n\n    // Show show Python UI after changing language\n    await page.getByRole('button', { name: /python/i }).click();\n\n    await expect(page.getByRole('button', { name: /main.py/i })).toBeVisible();\n    await expect(\n      page.getByRole('button', { name: /script.js/i })\n    ).not.toBeVisible();\n    await expect(page.getByRole('button', { name: /console/i })).toBeVisible();\n    await expect(page.getByTestId('preview-pane-button')).toBeVisible();\n    await expect(page.locator(\"div[role='code'].monaco-editor\")).toContainText(\n      '# Python seed code'\n    );\n\n    await page.goto(`/learn/daily-coding-challenge/${todayUsCentral}`);\n\n    await expect(page.getByRole('button', { name: /main.py/i })).toBeVisible();\n  });\n});\n\ntest.describe('Daily Coding Challenge Archive', () => {\n  test('/learn/daily-coding-challenge should redirect to archive', async ({\n    page\n  }) => {\n    await page.goto('/learn/daily-coding-challenge');\n    await expect(page).toHaveURL('/learn/daily-coding-challenge/archive');\n  });\n\n  test('/learn/daily-coding-challenge/ should redirect to archive', async ({\n    page\n  }) => {\n    await page.goto('/learn/daily-coding-challenge/');\n    await expect(page).toHaveURL('/learn/daily-coding-challenge/archive');\n  });\n\n  test('/learn/daily-coding-challenge/path-1/path2 should redirect to archive', async ({\n    page\n  }) => {\n    await page.goto('/learn/daily-coding-challenge/path-1/path2');\n    await expect(page).toHaveURL('/learn/daily-coding-challenge/archive');\n  });\n\n  test('archive should load and display the calendar', async ({ page }) => {\n    await page.route(allRouteRe, async route => {\n      await route.fulfill({\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        json: mockApiAllChallenges\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/archive');\n\n    await expect(page.getByText('Daily Coding Challenges')).toBeVisible();\n\n    await expect(\n      page.getByRole('button', { name: /previous month/i })\n    ).toBeVisible();\n    await expect(\n      page.getByRole('button', { name: /next month/i })\n    ).toBeVisible();\n\n    await expect(\n      page\n        .locator('div')\n        .filter({ hasText: /New challenges are released/ })\n        .getByRole('link', { name: /go to today/i })\n        .first()\n    ).toBeVisible();\n\n    const totalCalendarDays = await page.getByTestId('calendar-day').count();\n    expect(totalCalendarDays).toBe(mockDaysInMonth);\n\n    await expect(page.getByTestId('calendar-day-completed')).toHaveCount(1);\n\n    await expect(page.getByTestId('calendar-day-not-completed')).toHaveCount(3);\n  });\n});\n",
    "afterCode": "import { test, expect } from '@playwright/test';\nimport {\n  getTodayUsCentral,\n  formatDate,\n  formatDisplayDate\n} from '../client/src/components/daily-coding-challenge/helpers';\n\nconst dateRouteRe = /.*\\/daily-coding-challenge\\/date\\/.*/;\nconst allRouteRe = /.*\\/daily-coding-challenge\\/all/;\n\nconst todayUsCentral = getTodayUsCentral();\nconst [year, month, day] = todayUsCentral.split('-').map(Number);\n\nconst todayMidnight = `${todayUsCentral}T00:00:00.000Z`;\n\nconst mockApiChallenge = {\n  id: 'test-challenge-id',\n  challengeNumber: 1,\n  title: 'Test title',\n  date: todayMidnight,\n  description: 'Test description',\n  javascript: {\n    tests: [\n      {\n        text: 'Test text',\n        testString: 'assert.strictEqual(true, true);'\n      }\n    ],\n    challengeFiles: [\n      {\n        fileKey: 'scriptjs',\n        contents: '// JavaScript seed code'\n      }\n    ]\n  },\n  python: {\n    tests: [\n      {\n        text: 'Test text',\n        testString: '({test: () => { runPython(`assert True == True`)}})'\n      }\n    ],\n    challengeFiles: [\n      {\n        fileKey: 'mainpy',\n        contents: '# Python seed code'\n      }\n    ]\n  }\n};\n\nconst mockApiAllChallenges = [\n  // today\n  {\n    // real ID from certified user so it shows completed in calendar\n    id: '6814d8e1516e86b171929de4',\n    date: todayMidnight\n  },\n  // yesterday, or tomorrow if today is the first\n  {\n    id: 'other-id',\n    date: `${formatDate({ year, month, day: day === 1 ? day + 1 : day - 1 })}T00:00:00.000Z`\n  }\n];\n\nconst mockDaysInMonth = new Date(year, month, 0).getDate();\n\ntest.describe('Daily Coding Challenges', () => {\n  test('should show not found page for invalid date', async ({ page }) => {\n    await page.goto('/learn/daily-coding-challenge/invalid-date');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should show not found page for date without challenge', async ({\n    page\n  }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 404,\n        headers: { 'Content-Type': 'application/json' },\n        json: { type: 'error', message: 'Challenge not found.' }\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/2025-01-01');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should show not found page for API error', async ({ page }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n        json: { type: 'error', message: 'Internal server error.' }\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/2025-01-01');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should show not found page for invalid challenge data', async ({\n    page\n  }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        json: { invalid: 'data structure' }\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/2025-06-27');\n    await expect(\n      page.getByText(/daily coding challenge not found\\./i)\n    ).toBeVisible();\n  });\n\n  test('should load and display a daily coding challenge with a valid date, and should be able to switch between JavaScript and Python', async ({\n    page\n  }) => {\n    await page.route(dateRouteRe, async route => {\n      await route.fulfill({\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        json: mockApiChallenge\n      });\n    });\n\n    await page.goto(`/learn/daily-coding-challenge/${todayUsCentral}`);\n\n    const leftBreadcrumb = page.getByRole('link', {\n      name: /daily coding challenge/i\n    });\n    await expect(leftBreadcrumb).toBeVisible();\n    await expect(leftBreadcrumb).toHaveAttribute(\n      'href',\n      '/learn/daily-coding-challenge/archive'\n    );\n\n    const rightBreadcrumb = page.getByRole('link', {\n      name: `${formatDisplayDate(todayUsCentral)}`\n    });\n    await expect(rightBreadcrumb).toBeVisible();\n    await expect(rightBreadcrumb).toHaveAttribute(\n      'href',\n      '/learn/daily-coding-challenge/archive'\n    );\n\n    await expect(page.getByText('Test title')).toBeVisible();\n\n    await expect(page.getByText('Test description')).toBeVisible();\n\n    // Language buttons\n    await expect(\n      page.getByRole('button', { name: /javascript/i })\n    ).toBeVisible();\n    await expect(page.getByRole('button', { name: /python/i })).toBeVisible();\n\n    // Should show JS UI by default\n\n    await expect(\n      page.getByRole('button', { name: /script.js/i })\n    ).toBeVisible();\n    await expect(\n      page.getByRole('button', { name: /main.py/i })\n    ).not.toBeVisible();\n    await expect(page.getByRole('button', { name: /console/i })).toBeVisible();\n    await expect(page.getByTestId('preview-pane-button')).not.toBeVisible();\n    await expect(page.locator(\"div[role='code'].monaco-editor\")).toContainText(\n      '// JavaScript seed code'\n    );\n\n    // Show Python UI after changing language\n    await page.getByRole('button', { name: /python/i }).click();\n\n    await expect(page.getByRole('button', { name: /main.py/i })).toBeVisible();\n    await expect(\n      page.getByRole('button', { name: /script.js/i })\n    ).not.toBeVisible();\n    await expect(page.getByRole('button', { name: /console/i })).toBeVisible();\n    await expect(page.getByTestId('preview-pane-button')).toBeVisible();\n    await expect(page.locator(\"div[role='code'].monaco-editor\")).toContainText(\n      '# Python seed code'\n    );\n\n    await page.goto(`/learn/daily-coding-challenge/${todayUsCentral}`);\n\n    await expect(page.getByRole('button', { name: /main.py/i })).toBeVisible();\n  });\n});\n\ntest.describe('Daily Coding Challenge Archive', () => {\n  test('/learn/daily-coding-challenge should redirect to archive', async ({\n    page\n  }) => {\n    await page.goto('/learn/daily-coding-challenge');\n    await expect(page).toHaveURL('/learn/daily-coding-challenge/archive');\n  });\n\n  test('/learn/daily-coding-challenge/ should redirect to archive', async ({\n    page\n  }) => {\n    await page.goto('/learn/daily-coding-challenge/');\n    await expect(page).toHaveURL('/learn/daily-coding-challenge/archive');\n  });\n\n  test('/learn/daily-coding-challenge/path-1/path2 should redirect to archive', async ({\n    page\n  }) => {\n    await page.goto('/learn/daily-coding-challenge/path-1/path2');\n    await expect(page).toHaveURL('/learn/daily-coding-challenge/archive');\n  });\n\n  test('archive should load and display the calendar', async ({ page }) => {\n    await page.route(allRouteRe, async route => {\n      await route.fulfill({\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        json: mockApiAllChallenges\n      });\n    });\n\n    await page.goto('/learn/daily-coding-challenge/archive');\n\n    await expect(page.getByText('Daily Coding Challenges')).toBeVisible();\n\n    await expect(\n      page.getByRole('button', { name: /previous month/i })\n    ).toBeVisible();\n    await expect(\n      page.getByRole('button', { name: /next month/i })\n    ).toBeVisible();\n\n    await expect(\n      page\n        .locator('div')\n        .filter({ hasText: /New challenges are released/ })\n        .getByRole('link', { name: /go to today/i })\n        .first()\n    ).toBeVisible();\n\n    const totalCalendarDays = await page.getByTestId('calendar-day').count();\n    expect(totalCalendarDays).toBe(mockDaysInMonth);\n\n    await expect(page.getByTestId('calendar-day-completed')).toHaveCount(1);\n\n    await expect(page.getByTestId('calendar-day-not-completed')).toHaveCount(3);\n  });\n});\n",
    "linesChanged": 2,
    "complexity": 7789,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "a2c81caae6b89a6c6430a9b6691abb495090648a",
      "author": "Krzysztof G.",
      "date": "2025-11-19T15:49:58Z",
      "file": "e2e/daily-coding-challenge.spec.ts"
    }
  },
  {
    "id": "freeCodeCamp/freeCodeCamp-a605462f6fda63ac84029332d5dd93ee2d6e3003-client/src/utils/get-completion-percentage.ts",
    "language": "typescript",
    "errorType": "import-missing",
    "beforeCode": "import { AllChallengesInfo } from '../redux/prop-types';\nimport { isProjectBased } from './curriculum-layout';\n\nexport function getCompletedPercentage(\n  completedChallengesIds: string[] = [],\n  currentBlockIds: string[] = [],\n  currentChallengeId: string\n): number {\n  const completedChallengesInBlock = getCompletedChallengesInBlock(\n    completedChallengesIds,\n    currentBlockIds,\n    currentChallengeId\n  );\n  const completedPercent = Math.round(\n    (completedChallengesInBlock / currentBlockIds.length) * 100\n  );\n\n  return completedPercent > 100 ? 100 : completedPercent;\n}\n\nexport function getCompletedChallengesInBlock(\n  completedChallengesIds: string[],\n  currentBlockIds: string[],\n  currentChallengeId: string\n): number {\n  const oldCompletionCount = completedChallengesIds.filter(challengeId =>\n    currentBlockIds.includes(challengeId)\n  ).length;\n\n  const isAlreadyCompleted =\n    completedChallengesIds.includes(currentChallengeId);\n\n  return isAlreadyCompleted ? oldCompletionCount : oldCompletionCount + 1;\n}\n\nexport const getCurrentBlockIds = (\n  allChallengesInfo: AllChallengesInfo,\n  block: string,\n  certification: string,\n  challengeType: number\n): string[] => {\n  const { challengeNodes, certificateNodes } = allChallengesInfo;\n  const currentCertificateIds =\n    certificateNodes\n      .filter(node => node.challenge.certification === certification)[0]\n      ?.challenge.tests.map(test => test.id) ?? [];\n  const currentBlockIds = challengeNodes\n    .filter(node => node.challenge.block === block)\n    .map(node => node.challenge.id);\n\n  return isProjectBased(challengeType)\n    ? currentCertificateIds\n    : currentBlockIds;\n};\n",
    "afterCode": "import { AllChallengesInfo } from '../redux/prop-types';\nimport { isProjectBased } from './curriculum-layout';\n\nexport function getCompletedPercentage(\n  completedChallengesIds: string[] = [],\n  currentBlockIds: string[] = [],\n  currentChallengeId: string\n): number {\n  const completedChallengesInBlock = getCompletedChallengesInBlock(\n    completedChallengesIds,\n    currentBlockIds,\n    currentChallengeId\n  );\n  const completedPercent = Math.round(\n    (completedChallengesInBlock / currentBlockIds.length) * 100\n  );\n\n  return completedPercent > 100 ? 100 : completedPercent;\n}\n\nexport function getCompletedChallengesInBlock(\n  completedChallengesIds: string[],\n  currentBlockIds: string[],\n  currentChallengeId: string\n): number {\n  const oldCompletionCount = completedChallengesIds.filter(challengeId =>\n    currentBlockIds.includes(challengeId)\n  ).length;\n\n  const isAlreadyCompleted =\n    completedChallengesIds.includes(currentChallengeId);\n\n  return isAlreadyCompleted ? oldCompletionCount : oldCompletionCount + 1;\n}\n\nexport const getCurrentBlockIds = (\n  allChallengesInfo: AllChallengesInfo,\n  block: string,\n  certification: string,\n  challengeType: number\n): string[] => {\n  const { challengeNodes, certificateNodes } = allChallengesInfo;\n  const currentCertificateIds =\n    certificateNodes\n      .filter(node => node.challenge.certification === certification)[0]\n      ?.challenge.tests.map(test => test.id) ?? [];\n  const currentBlockIds = challengeNodes\n    .filter(node => node.challenge.block === block)\n    .map(node => node.challenge.id);\n\n  if (isProjectBased(challengeType)) {\n    return currentCertificateIds.length > 0\n      ? currentCertificateIds\n      : currentBlockIds;\n  }\n\n  return currentBlockIds;\n};\n",
    "linesChanged": 10,
    "complexity": 1739,
    "fixSucceeded": true,
    "metadata": {
      "repo": "freeCodeCamp/freeCodeCamp",
      "commitSha": "a605462f6fda63ac84029332d5dd93ee2d6e3003",
      "author": "Fernando Belmonte Archetti",
      "date": "2025-11-18T08:15:40Z",
      "file": "client/src/utils/get-completion-percentage.ts"
    }
  }
]