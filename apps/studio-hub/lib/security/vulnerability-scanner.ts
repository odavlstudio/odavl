/**
 * Security Vulnerability Scanner
 *
 * Automated security scanning for dependencies and code vulnerabilities.
 * Integrates with npm audit, Snyk, and custom security checks.
 *
 * SOC 2 Requirements:
 * - CC7.1: Detection of security events
 * - CC7.2: Monitoring activities
 * - CC7.3: Evaluation of security events
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { logger } from '@/lib/logger';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

export enum VulnerabilitySeverity {
  INFO = 'info',
  LOW = 'low',
  MODERATE = 'moderate',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export interface Vulnerability {
  id: string;
  title: string;
  severity: VulnerabilitySeverity;
  package: string;
  version: string;
  patchedIn?: string;
  description: string;
  recommendation: string;
  cve?: string;
  cvss?: number;
  url?: string;
}

export interface ScanResult {
  timestamp: Date;
  totalVulnerabilities: number;
  vulnerabilities: Vulnerability[];
  summary: {
    info: number;
    low: number;
    moderate: number;
    high: number;
    critical: number;
  };
  passed: boolean;
}

/**
 * Type for npm audit vulnerability entry
 */
interface NpmVulnerability {
  severity: string;
  range?: string;
  fixAvailable?: { version: string };
  via: Array<{
    source?: number;
    title?: string;
    cve?: string;
    cvss?: { score: number };
    url?: string;
  }>;
}

/**
 * Helper function to parse a single npm vulnerability entry
 */
function parseNpmVulnerability(pkg: string, vuln: NpmVulnerability): Vulnerability {
  const viaInfo = vuln.via[0] || {};

  return {
    id: viaInfo.source?.toString() || pkg,
    title: viaInfo.title || `Vulnerability in ${pkg}`,
    severity: mapSeverity(vuln.severity),
    package: pkg,
    version: vuln.range || 'unknown',
    patchedIn: vuln.fixAvailable?.version,
    description: viaInfo.title || 'No description available',
    recommendation: vuln.fixAvailable
      ? `Update to version ${vuln.fixAvailable.version}`
      : 'No fix available yet',
    cve: viaInfo.cve,
    cvss: viaInfo.cvss?.score,
    url: viaInfo.url,
  };
}

/**
 * Run npm audit and parse results
 * Reduced complexity: cyclomatic 25‚Üí10
 */
export async function runNpmAudit(): Promise<ScanResult> {
  try {
    const { stdout } = await execAsync('pnpm audit --json', {
      cwd: process.cwd(),
    });

    const auditData = JSON.parse(stdout);
    const vulnerabilities: Vulnerability[] = [];

    // Parse npm audit output
    for (const [pkg, data] of Object.entries(auditData.vulnerabilities || {})) {
      const vuln = data as NpmVulnerability;
      vulnerabilities.push(parseNpmVulnerability(pkg, vuln));
    }

    return createScanResult(vulnerabilities);
  } catch (error) {
    logger.error('npm audit failed', error as Error);
    return createScanResult([]);
  }
}

/**
 * Check for outdated dependencies
 */
export async function checkOutdatedDependencies(): Promise<{
  outdated: Array<{
    package: string;
    current: string;
    wanted: string;
    latest: string;
  }>;
  total: number;
}> {
  try {
    const { stdout } = await execAsync('pnpm outdated --json', {
      cwd: process.cwd(),
    });

    const outdatedData = JSON.parse(stdout);
    const outdated = Object.entries(outdatedData).map(([pkg, data]: [string, any]) => ({
      package: pkg,
      current: data.current,
      wanted: data.wanted,
      latest: data.latest,
    }));

    return {
      outdated,
      total: outdated.length,
    };
  } catch (error) {
    return { outdated: [], total: 0 };
  }
}

/**
 * Scan for hardcoded secrets in code
 */
export async function scanForSecrets(directory: string): Promise<{
  findings: Array<{
    file: string;
    line: number;
    type: string;
    match: string;
  }>;
  total: number;
}> {
  const findings: Array<{
    file: string;
    line: number;
    type: string;
    match: string;
  }> = [];

  const secretPatterns = [
    { type: 'AWS Access Key', regex: /AKIA[0-9A-Z]{16}/ },
    { type: 'AWS Secret Key', regex: /aws_secret_access_key\s*=\s*[\'\"]?([A-Za-z0-9/+=]{40})[\'\"]?/ },
    { type: 'GitHub Token', regex: /ghp_[a-zA-Z0-9]{36}/ },
    { type: 'GitHub OAuth', regex: /gho_[a-zA-Z0-9]{36}/ },
    { type: 'Slack Token', regex: /xox[baprs]-[0-9a-zA-Z]{10,48}/ },
    { type: 'Stripe Key', regex: /sk_live_[0-9a-zA-Z]{24}/ },
    { type: 'Private Key', regex: /-----BEGIN (RSA|EC|OPENSSH|PGP) PRIVATE KEY-----/ },
    { type: 'Database URL', regex: /postgresql:\/\/[^:]+:[^@]+@[^\/]+\/\w+/ },
    { type: 'JWT Token', regex: /eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*/ },
  ];

  async function scanFile(filePath: string) {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n');

      lines.forEach((line, index) => {
        // Skip environment variable declarations
        if (line.includes('process.env.') || line.startsWith('#')) {
          return;
        }

        secretPatterns.forEach(pattern => {
          const match = line.match(pattern.regex);
          if (match) {
            findings.push({
              file: filePath,
              line: index + 1,
              type: pattern.type,
              match: match[0].substring(0, 20) + '...',
            });
          }
        });
      });
    } catch (error) {
      // Ignore read errors
    }
  }

  async function scanDirectory(dir: string) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      // Skip node_modules, .git, dist, etc.
      if (entry.name === 'node_modules' ||
          entry.name === '.git' ||
          entry.name === 'dist' ||
          entry.name === '.next' ||
          entry.name === 'coverage') {
        continue;
      }

      if (entry.isDirectory()) {
        await scanDirectory(fullPath);
      } else if (entry.isFile() &&
                 (entry.name.endsWith('.ts') ||
                  entry.name.endsWith('.tsx') ||
                  entry.name.endsWith('.js') ||
                  entry.name.endsWith('.jsx') ||
                  entry.name.endsWith('.env'))) {
        await scanFile(fullPath);
      }
    }
  }

  await scanDirectory(directory);

  return {
    findings,
    total: findings.length,
  };
}

/**
 * Check for insecure HTTP requests
 */
export async function checkInsecureRequests(directory: string): Promise<{
  findings: Array<{
    file: string;
    line: number;
    url: string;
  }>;
  total: number;
}> {
  const findings: Array<{
    file: string;
    line: number;
    url: string;
  }> = [];

  const httpPattern = /http:\/\/(?!localhost|127\.0\.0\.1)[^\s'"]+/g;

  async function scanFile(filePath: string) {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n');

      lines.forEach((line, index) => {
        const matches = line.matchAll(httpPattern);
        for (const match of matches) {
          findings.push({
            file: filePath,
            line: index + 1,
            url: match[0],
          });
        }
      });
    } catch (error) {
      // Ignore read errors
    }
  }

  async function scanDirectory(dir: string) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.name === 'node_modules' || entry.name === '.git') {
        continue;
      }

      if (entry.isDirectory()) {
        await scanDirectory(fullPath);
      } else if (entry.isFile() &&
                 (entry.name.endsWith('.ts') ||
                  entry.name.endsWith('.tsx') ||
                  entry.name.endsWith('.js') ||
                  entry.name.endsWith('.jsx'))) {
        await scanFile(fullPath);
      }
    }
  }

  await scanDirectory(directory);

  return {
    findings,
    total: findings.length,
  };
}

/**
 * Run comprehensive security scan
 */
export async function runSecurityScan(): Promise<{
  npmAudit: ScanResult;
  outdatedDeps: Awaited<ReturnType<typeof checkOutdatedDependencies>>;
  secrets: Awaited<ReturnType<typeof scanForSecrets>>;
  insecureRequests: Awaited<ReturnType<typeof checkInsecureRequests>>;
  passed: boolean;
  score: number;
}> {
  logger.emoji('üîç', 'Running security scan...');

  const [npmAudit, outdatedDeps, secrets, insecureRequests] = await Promise.all([
    runNpmAudit(),
    checkOutdatedDependencies(),
    scanForSecrets(process.cwd()),
    checkInsecureRequests(process.cwd()),
  ]);

  // Calculate security score (0-100)
  let score = 100;

  // Deduct points for vulnerabilities
  score -= npmAudit.summary.critical * 20;
  score -= npmAudit.summary.high * 10;
  score -= npmAudit.summary.moderate * 5;
  score -= npmAudit.summary.low * 2;

  // Deduct points for secrets
  score -= secrets.total * 15;

  // Deduct points for insecure requests
  score -= insecureRequests.total * 5;

  score = Math.max(0, score);

  const passed = score >= 80 &&
                 npmAudit.summary.critical === 0 &&
                 npmAudit.summary.high === 0 &&
                 secrets.total === 0;

  return {
    npmAudit,
    outdatedDeps,
    secrets,
    insecureRequests,
    passed,
    score,
  };
}

/**
 * Generate security report
 */
export async function generateSecurityReport(): Promise<string> {
  const scan = await runSecurityScan();

  const report = `
# Security Scan Report
Generated: ${new Date().toISOString()}

## Overall Score: ${scan.score}/100 ${scan.passed ? '‚úÖ' : '‚ùå'}

## NPM Audit Results
- Total Vulnerabilities: ${scan.npmAudit.totalVulnerabilities}
- Critical: ${scan.npmAudit.summary.critical}
- High: ${scan.npmAudit.summary.high}
- Moderate: ${scan.npmAudit.summary.moderate}
- Low: ${scan.npmAudit.summary.low}

## Outdated Dependencies
- Total: ${scan.outdatedDeps.total}

## Secret Scanning
- Hardcoded Secrets Found: ${scan.secrets.total}
${scan.secrets.findings.map(f => `  - ${f.type} in ${f.file}:${f.line}`).join('\n')}

## Insecure HTTP Requests
- Total: ${scan.insecureRequests.total}
${scan.insecureRequests.findings.map(f => `  - ${f.url} in ${f.file}:${f.line}`).join('\n')}

## Recommendations
${scan.npmAudit.summary.critical > 0 ? '‚ö†Ô∏è  URGENT: Fix critical vulnerabilities immediately\n' : ''}
${scan.secrets.total > 0 ? '‚ö†Ô∏è  URGENT: Remove hardcoded secrets and use environment variables\n' : ''}
${scan.insecureRequests.total > 0 ? '‚ö†Ô∏è  Replace HTTP requests with HTTPS\n' : ''}
${scan.outdatedDeps.total > 10 ? '‚ö†Ô∏è  Consider updating outdated dependencies\n' : ''}
${scan.passed ? '‚úÖ Security scan passed! No critical issues found.\n' : ''}
`;

  return report;
}

// Helper functions

function mapSeverity(severity: string): VulnerabilitySeverity {
  const map: Record<string, VulnerabilitySeverity> = {
    info: VulnerabilitySeverity.INFO,
    low: VulnerabilitySeverity.LOW,
    moderate: VulnerabilitySeverity.MODERATE,
    high: VulnerabilitySeverity.HIGH,
    critical: VulnerabilitySeverity.CRITICAL,
  };

  return map[severity.toLowerCase()] || VulnerabilitySeverity.MODERATE;
}

function createScanResult(vulnerabilities: Vulnerability[]): ScanResult {
  const summary = {
    info: 0,
    low: 0,
    moderate: 0,
    high: 0,
    critical: 0,
  };

  vulnerabilities.forEach(v => {
    summary[v.severity]++;
  });

  const passed = summary.critical === 0 && summary.high === 0;

  return {
    timestamp: new Date(),
    totalVulnerabilities: vulnerabilities.length,
    vulnerabilities,
    summary,
    passed,
  };
}
