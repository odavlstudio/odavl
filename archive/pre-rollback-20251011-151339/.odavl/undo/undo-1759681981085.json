{
  "timestamp": "2025-10-05T16:33:01.085Z",
  "modifiedFiles": [
    "apps/cli/src/index.ts",
    "package.json",
    "tsconfig.json"
  ],
  "data": {
    "apps/cli/src/index.ts": "import { execSync, spawnSync } from \"node:child_process\";\r\nimport * as fs from \"node:fs\";\r\nimport * as path from \"node:path\";\r\nimport yaml from \"js-yaml\";\r\n\r\ntype Metrics = { eslintWarnings: number; typeErrors: number; timestamp: string };\r\ntype RunReport = {\r\n  before: Metrics;\r\n  after: Metrics;\r\n  deltas: { eslint: number; types: number };\r\n  decision: string;\r\n  gatesPassed?: boolean;\r\n  gates?: unknown;\r\n};\r\n\r\ntype Recipe = { id: string; trust?: number; [key: string]: unknown };\r\ntype TrustRecord = { id: string; runs: number; success: number; trust: number };\r\ntype GatesConfig = { eslint?: { deltaMax: number }; typeErrors?: { deltaMax: number }; [key: string]: unknown };\r\n\r\nconst ROOT = process.cwd();\r\nconst reportsDir = path.join(ROOT, \"reports\");\r\nconst odavlDir = path.join(ROOT, \".odavl\");\r\nconst _unusedVar = \"test\"; // This will create an ESLint warning (but now ignored)\r\n\r\n// Check if --json flag is passed for structured output\r\nconst isJsonMode = process.argv.includes(\"--json\");\r\n\r\nfunction logPhase(phase: string, msg: string, status: \"info\" | \"success\" | \"error\" = \"info\") {\r\n  if (isJsonMode) {\r\n    console.log(JSON.stringify({ type: \"doctor\", status, data: { phase, msg } }));\r\n  } else {\r\n    console.log(`[${phase}] ${msg}`);\r\n  }\r\n}\r\n\r\nfunction sh(cmd: string): { out: string; err: string } {\r\n  try {\r\n    const out = execSync(cmd, { stdio: [\"ignore\", \"pipe\", \"pipe\"] }).toString();\r\n    return { out, err: \"\" };\r\n  } catch (e: unknown) {\r\n    const execError = e as { stdout?: Buffer; stderr?: Buffer };\r\n    const out = execError.stdout?.toString() ?? \"\";\r\n    const err = execError.stderr?.toString() ?? \"\";\r\n    return { out, err };\r\n  }\r\n}\r\n\r\nfunction ensureDirs() {\r\n  if (!fs.existsSync(reportsDir)) fs.mkdirSync(reportsDir, { recursive: true });\r\n  if (!fs.existsSync(odavlDir)) fs.mkdirSync(odavlDir, { recursive: true });\r\n}\r\n\r\nfunction loadRecipes(): Recipe[] {\r\n  const rDir = path.join(odavlDir, \"recipes\");\r\n  const list: Recipe[] = [];\r\n  if (fs.existsSync(rDir)) {\r\n    for (const f of fs.readdirSync(rDir)) {\r\n      const fp = path.join(rDir, f);\r\n      try { list.push(JSON.parse(fs.readFileSync(fp, \"utf8\"))); } catch { /* ignore */ }\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\nfunction updateTrust(recipeId: string, success: boolean) {\r\n  const trustPath = path.join(odavlDir, \"recipes-trust.json\");\r\n  let arr: TrustRecord[] = [];\r\n  if (fs.existsSync(trustPath)) {\r\n    try { arr = JSON.parse(fs.readFileSync(trustPath, \"utf8\")); } catch { /* ignore */ }\r\n  }\r\n  let r = arr.find((x) => x.id === recipeId);\r\n  if (!r) { r = { id: recipeId, runs: 0, success: 0, trust: 0.8 }; arr.push(r); }\r\n  r.runs++;\r\n  if (success) r.success++;\r\n  r.trust = Math.max(0.1, Math.min(1, r.success / r.runs));\r\n  fs.writeFileSync(trustPath, JSON.stringify(arr, null, 2));\r\n}\r\n\r\nfunction observe(): Metrics {\r\n  ensureDirs();\r\n  // ESLint JSON\r\n  const eslintRes = sh(\"pnpm -s exec eslint . -f json\");\r\n  let eslintWarnings = 0;\r\n  try {\r\n    const parsed = JSON.parse(eslintRes.out || \"[]\");\r\n    if (Array.isArray(parsed)) {\r\n      for (const file of parsed) {\r\n        for (const msg of file.messages || []) {\r\n          if (msg.severity === 1) eslintWarnings++;\r\n        }\r\n      }\r\n    }\r\n  } catch {\r\n    // If parsing fails, fallback to 0 warnings\r\n  }\r\n\r\n  // TypeScript noEmit\r\n  const tscRes = sh(\"pnpm -s exec tsc -p tsconfig.json --noEmit\");\r\n  const typeErrors = (tscRes.out + tscRes.err).match(/error TS\\d+/g)?.length ?? 0;\r\n\r\n  const metrics: Metrics = { eslintWarnings, typeErrors, timestamp: new Date().toISOString() };\r\n  fs.writeFileSync(path.join(reportsDir, `observe-${Date.now()}.json`), JSON.stringify(metrics, null, 2));\r\n  return metrics;\r\n}\r\n\r\nfunction decide(_m: Metrics): string {\r\n  const recipes = loadRecipes();\r\n  if (!recipes.length) return \"noop\";\r\n  const sorted = [...recipes].sort((a,b) => (b.trust ?? 0) - (a.trust ?? 0));\r\n  const best = sorted[0];\r\n  logPhase(\"DECIDE\", `Selected recipe: ${best.id} (trust ${best.trust})`, \"info\");\r\n  return best.id;\r\n}\r\n\r\nfunction act(decision: string) {\r\n  if (decision === \"remove-unused\" || decision === \"esm-hygiene\" || decision === \"format-consistency\") {\r\n    saveUndoSnapshot([\"apps/cli/src/index.ts\", \"package.json\", \"tsconfig.json\"]);\r\n    logPhase(\"ACT\", \"Running eslint --fix …\", \"info\");\r\n    sh(\"pnpm -s exec eslint . --fix\");\r\n  } else {\r\n    logPhase(\"ACT\", \"noop (nothing to fix)\", \"info\");\r\n  }\r\n}\r\n\r\nfunction checkGates(deltas: { eslint: number; types: number }): { passed: boolean; gates: unknown; violations: string[] } {\r\n  const gatesPath = path.join(odavlDir, \"gates.yml\");\r\n  let gates: unknown = {};\r\n  if (fs.existsSync(gatesPath)) {\r\n    try { gates = yaml.load(fs.readFileSync(gatesPath, \"utf8\")); } catch { /* ignore */ }\r\n  }\r\n  \r\n  const violations: string[] = [];\r\n  const g = gates as GatesConfig;\r\n  if (g.eslint?.deltaMax !== undefined && deltas.eslint > g.eslint.deltaMax) {\r\n    violations.push(`ESLint delta ${deltas.eslint} > ${g.eslint.deltaMax}`);\r\n  }\r\n  if (g.typeErrors?.deltaMax !== undefined && deltas.types > g.typeErrors.deltaMax) {\r\n    violations.push(`Type errors delta ${deltas.types} > ${g.typeErrors.deltaMax}`);\r\n  }\r\n  \r\n  const passed = violations.length === 0;\r\n  logPhase(\"VERIFY\", passed ? \"Gates check: PASS ✅\" : `Gates check: FAIL ❌ (${violations.join(', ')})`, passed ? \"success\" : \"error\");\r\n  return { passed, gates, violations };\r\n}\r\n\r\nfunction verify(before: Metrics): { after: Metrics; deltas: { eslint: number; types: number }; gatesPassed: boolean; gates: unknown } {\r\n  const after = observe();\r\n  const deltas = {\r\n    eslint: after.eslintWarnings - before.eslintWarnings,\r\n    types: after.typeErrors - before.typeErrors\r\n  };\r\n  \r\n  const shadowPassed = runShadowVerify();\r\n  if (!shadowPassed) {\r\n    const verify = { after, deltas, gatesPassed: false, gates: {} };\r\n    fs.writeFileSync(path.join(reportsDir, `verify-${Date.now()}.json`), JSON.stringify(verify, null, 2));\r\n    return verify;\r\n  }\r\n  \r\n  const gatesResult = checkGates(deltas);\r\n  const verify = { after, deltas, gatesPassed: gatesResult.passed, gates: gatesResult.gates };\r\n  fs.writeFileSync(path.join(reportsDir, `verify-${Date.now()}.json`), JSON.stringify(verify, null, 2));\r\n  return verify;\r\n}\r\n\r\nfunction learn(report: RunReport) {\r\n  const success = report.deltas.eslint < 0 || report.deltas.types <= 0;\r\n  updateTrust(report.decision, success);\r\n  const histPath = path.join(odavlDir, \"history.json\");\r\n  let arr: unknown[] = [];\r\n  if (fs.existsSync(histPath)) {\r\n    try { arr = JSON.parse(fs.readFileSync(histPath, \"utf8\")); } catch { /* ignore */ }\r\n  }\r\n  arr.push({ ts: new Date().toISOString(), success, ...report });\r\n  fs.writeFileSync(histPath, JSON.stringify(arr, null, 2));\r\n  if (report.gatesPassed) writeAttestation(report);\r\n}\r\n\r\nfunction writeAttestation(report: RunReport) {\r\n  const attDir = path.join(odavlDir, \"attestation\");\r\n  if (!fs.existsSync(attDir)) fs.mkdirSync(attDir, { recursive: true });\r\n  const file = path.join(attDir, `attestation-${new Date().toISOString().replace(/[:.]/g,\"\")}.json`);\r\n  const payload = {\r\n    planId: \"W3-\" + new Date().toISOString(),\r\n    timestamp: new Date().toISOString(),\r\n    recipe: report.decision,\r\n    deltas: report.deltas,\r\n    verified: report.gatesPassed,\r\n    gates: report.gates,\r\n    signature: \"sig-\" + Math.random().toString(36).substring(2,10)\r\n  };\r\n  fs.writeFileSync(file, JSON.stringify(payload, null, 2));\r\n  fs.writeFileSync(path.join(attDir, \"latest.json\"), JSON.stringify(payload, null, 2));\r\n  console.log(`[LEARN] Attestation saved → ${file}`);\r\n}\r\n\r\nfunction runShadowVerify(): boolean {\r\n  const shadowDir = path.join(odavlDir, \"shadow\");\r\n  if (!fs.existsSync(shadowDir)) fs.mkdirSync(shadowDir, { recursive: true });\r\n  console.log(\"[SHADOW] Verifying in isolated environment...\");\r\n  try {\r\n    const cmds = [\r\n      \"pnpm run lint\",\r\n      \"pnpm run typecheck\"\r\n    ];\r\n    for (const cmd of cmds) {\r\n      console.log(\"[SHADOW]\", cmd);\r\n      const res = spawnSync(cmd, { shell: true, cwd: process.cwd(), stdio: \"inherit\" });\r\n      if (res.status !== 0) throw new Error(cmd + \" failed\");\r\n    }\r\n    fs.writeFileSync(path.join(shadowDir, \"verify.log\"), \"[PASS] All checks passed\");\r\n    console.log(\"[SHADOW] ✅ All checks passed\");\r\n    return true;\r\n  } catch (err) {\r\n    fs.writeFileSync(path.join(shadowDir, \"verify.log\"), \"[FAIL] \" + (err as Error).message);\r\n    console.log(\"[SHADOW] ❌ Verification failed\");\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction saveUndoSnapshot(modifiedFiles: string[]) {\r\n  const undoDir = path.join(odavlDir, \"undo\");\r\n  if (!fs.existsSync(undoDir)) fs.mkdirSync(undoDir, { recursive: true });\r\n  const snap = {\r\n    timestamp: new Date().toISOString(),\r\n    modifiedFiles,\r\n    data: {} as Record<string, string | null>\r\n  };\r\n  for (const f of modifiedFiles) {\r\n    snap.data[f] = fs.existsSync(f) ? fs.readFileSync(f, \"utf8\") : null;\r\n  }\r\n  const file = path.join(undoDir, `undo-${Date.now()}.json`);\r\n  fs.writeFileSync(file, JSON.stringify(snap, null, 2));\r\n  fs.writeFileSync(path.join(undoDir, \"latest.json\"), JSON.stringify(snap, null, 2));\r\n  console.log(\"[UNDO] Snapshot saved:\", file);\r\n}\r\n\r\nfunction undoLast() {\r\n  const undoDir = path.join(odavlDir, \"undo\");\r\n  const latest = path.join(undoDir, \"latest.json\");\r\n  if (!fs.existsSync(latest)) return console.log(\"[UNDO] No undo snapshot found.\");\r\n  const snap = JSON.parse(fs.readFileSync(latest, \"utf8\"));\r\n  for (const [f, content] of Object.entries(snap.data)) {\r\n    if (content) fs.writeFileSync(f, content as string);\r\n  }\r\n  console.log(\"[UNDO] Project reverted to last safe state (\" + snap.timestamp + \")\");\r\n}\r\n\r\nfunction runCycle() {\r\n  logPhase(\"ODAVL\", \"Observe → Decide → Act → Verify → Learn\", \"info\");\r\n  const before = observe();\r\n  logPhase(\"OBSERVE\", `ESLint warnings: ${before.eslintWarnings}, Type errors: ${before.typeErrors}`, \"info\");\r\n  const decision = decide(before);\r\n  logPhase(\"DECIDE\", decision, \"info\");\r\n  act(decision);\r\n  const { after, deltas, gatesPassed, gates } = verify(before);\r\n  const report: RunReport = { before, after, deltas, decision, gatesPassed, gates };\r\n  const runFile = path.join(reportsDir, `run-${Date.now()}.json`);\r\n  fs.writeFileSync(runFile, JSON.stringify(report, null, 2));\r\n  learn(report);\r\n  const status = gatesPassed ? \"success\" : \"error\";\r\n  logPhase(\"DONE\", `ESLint warnings: ${before.eslintWarnings} → ${after.eslintWarnings} (Δ ${deltas.eslint}) | Type errors: ${before.typeErrors} → ${after.typeErrors} (Δ ${deltas.types})`, status);\r\n}\r\n\r\nconst cmd = process.argv[2] ?? \"help\";\r\nif (cmd === \"observe\")      { const m = observe(); console.log(m); }\r\nelse if (cmd === \"decide\")  { const d = decide(observe()); console.log(d); }\r\nelse if (cmd === \"act\")     { act(\"remove-unused\"); console.log(\"act done\"); }\r\nelse if (cmd === \"verify\")  { const v = verify(observe()); console.log(v); }\r\nelse if (cmd === \"run\")     { runCycle(); }\r\nelse if (cmd === \"undo\")    { undoLast(); }\r\nelse {\r\n  console.log(\"Usage: tsx apps/cli/src/index.ts <observe|decide|act|verify|run|undo>\");\r\n}",
    "package.json": "{\n  \"name\": \"odavl\",\n  \"private\": true,\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"engines\": {\n    \"node\": \">=18.18\"\n  },\n  \"packageManager\": \"pnpm@9.12.2\",\n  \"scripts\": {\n    \"lint\": \"eslint .\",\n    \"typecheck\": \"tsc -p tsconfig.json --noEmit\",\n    \"odavl:run\": \"tsx apps/cli/src/index.ts run\",\n    \"odavl:observe\": \"tsx apps/cli/src/index.ts observe\",\n    \"odavl:decide\": \"tsx apps/cli/src/index.ts decide\",\n    \"odavl:act\": \"tsx apps/cli/src/index.ts act\",\n    \"odavl:verify\": \"tsx apps/cli/src/index.ts verify\",\n    \"ext:compile\": \"cd apps/vscode-ext && npm run compile\",\n    \"ext:watch\": \"cd apps/vscode-ext && npm run watch\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"9.11.0\",\n    \"@types/node\": \"^24.6.2\",\n    \"eslint\": \"9.11.0\",\n    \"tsx\": \"4.19.1\",\n    \"typescript\": \"5.6.3\",\n    \"typescript-eslint\": \"8.7.0\"\n  },\n  \"dependencies\": {\n    \"js-yaml\": \"^4.1.0\"\n  }\n}\n",
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ES2022\",\n    \"moduleResolution\": \"Bundler\",\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\"apps\", \"packages\"]\n}\r\n"
  }
}